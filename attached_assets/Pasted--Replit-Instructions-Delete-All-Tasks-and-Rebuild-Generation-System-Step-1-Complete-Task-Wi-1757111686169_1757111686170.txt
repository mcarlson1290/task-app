# Replit Instructions: Delete All Tasks and Rebuild Generation System

## Step 1: Complete Task Wipe

Add a button to delete ALL task instances (but keep recurring templates):

```javascript
<button
  onClick={async () => {
    if (!confirm('This will DELETE ALL TASKS. Recurring templates will remain. Continue?')) {
      return;
    }
    
    const allTasks = await getAllTasks();
    console.log(`Deleting ${allTasks.length} tasks...`);
    
    for (const task of allTasks) {
      await deleteTask(task.id);
    }
    
    console.log('All tasks deleted. Ready for fresh generation.');
    alert('All tasks deleted. Now run task generation.');
    window.location.reload();
  }}
  className="px-4 py-2 bg-red-600 text-white rounded font-bold"
>
  ğŸ—‘ï¸ DELETE ALL TASKS (Start Fresh)
</button>
```

## Step 2: Build Proper Generation System

After deleting all tasks, implement real generation that:

1. **Reads from recurring task templates** (the source of truth)
2. **Creates task instances** for the next 31 days
3. **Respects visibility windows** for each frequency type
4. **Prevents duplicates** by checking task IDs

## Step 3: The Generation Function

```javascript
const generateTasksFromTemplates = async () => {
  console.log('Starting fresh task generation...');
  
  const templates = await getRecurringTasks(); // Get all recurring templates
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  
  let created = 0;
  
  // Look at each day for the next 31 days
  for (let day = 0; day < 31; day++) {
    const checkDate = new Date(today);
    checkDate.setDate(today.getDate() + day);
    
    for (const template of templates) {
      // Determine if this template should generate a task on this date
      const shouldGenerate = shouldGenerateOnDate(template, checkDate);
      
      if (shouldGenerate) {
        const taskData = buildTaskFromTemplate(template, checkDate);
        
        // Check if task already exists
        const exists = await getTaskById(taskData.id);
        if (!exists) {
          await saveTask(taskData);
          created++;
          console.log(`Created: ${taskData.title} - ${taskData.id}`);
        }
      }
    }
  }
  
  console.log(`Generation complete. Created ${created} new tasks.`);
  return created;
};
```

## Step 4: Generation Rules by Frequency

Define when each frequency type generates tasks:

**Weekly (daily)**:
- Generate if day matches selected days
- Task ID: `{templateId}-{YYYY-MM-DD}`

**Bi-Weekly**:
- Generate on 1st for first half (due 14th)
- Generate on 15th for second half (due end of month)
- Task IDs: `{templateId}-{YYYY-MM}-01` or `{templateId}-{YYYY-MM}-15`

**Monthly**:
- Generate on 1st of each month
- Task ID: `{templateId}-{YYYY-MM}`

**Quarterly**:
- Generate on 1st of quarter months (Jan, Apr, Jul, Oct)
- Task ID: `{templateId}-{YYYY}-Q{quarter}`

## Step 5: Run Generation After Wipe

Add a button to generate all tasks:

```javascript
<button
  onClick={async () => {
    const count = await generateTasksFromTemplates();
    alert(`Generated ${count} tasks for the next 31 days`);
    window.location.reload();
  }}
  className="px-4 py-2 bg-green-600 text-white rounded font-bold"
>
  ğŸ”„ Generate Tasks for Next 31 Days
</button>
```

## Step 6: Auto-Generation on Load

Make the system generate missing tasks automatically:

```javascript
useEffect(() => {
  const checkAndGenerate = async () => {
    // Generate any missing tasks for the next 31 days
    const count = await generateTasksFromTemplates();
    if (count > 0) {
      console.log(`Auto-generated ${count} missing tasks`);
    }
  };
  
  checkAndGenerate();
}, []);
```

## Step 7: Handle Template Updates

When a recurring template is edited:

```javascript
const onTemplateUpdate = async (templateId) => {
  // Delete future tasks from this template
  const allTasks = await getAllTasks();
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  
  const futureTasks = allTasks.filter(task => 
    task.recurringTaskId === templateId &&
    new Date(task.dueDate) >= today &&
    task.status === 'pending'
  );
  
  for (const task of futureTasks) {
    await deleteTask(task.id);
  }
  
  // Regenerate tasks for this template
  await generateTasksFromTemplates();
};
```

## The Clean Slate Approach

1. **Delete ALL existing tasks** (they're static and broken)
2. **Keep recurring templates** (these are your source of truth)
3. **Generate fresh tasks** from templates for next 31 days
4. **Template changes now affect future tasks** (because they're generated from templates)

## Expected Result

After the wipe and regeneration:
- No duplicate tasks
- All tasks match their recurring templates
- Changing a template updates future instances
- New tasks generate automatically as time progresses
- Consistent formatting and badges

## Why This Works

The current tasks were created as independent entities, not generated from templates. By wiping them and building proper generation, you get a system where:
- Templates are the single source of truth
- Tasks are just time-scheduled instances of templates
- Everything stays in sync