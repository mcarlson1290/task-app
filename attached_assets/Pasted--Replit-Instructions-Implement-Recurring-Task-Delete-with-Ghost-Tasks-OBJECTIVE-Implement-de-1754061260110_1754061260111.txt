# Replit Instructions: Implement Recurring Task Delete with Ghost Tasks

**OBJECTIVE: Implement delete functionality that removes future tasks but preserves history as ghost tasks**

## Step 1: Add Delete Confirmation Modal

Create a confirmation modal with clear warning:

```tsx
const DeleteRecurringTaskModal = ({ recurringTask, isOpen, onClose, onConfirm }) => {
  const [confirmText, setConfirmText] = useState('');
  const [taskCounts, setTaskCounts] = useState({ future: 0, completed: 0, inProgress: 0 });

  useEffect(() => {
    if (isOpen && recurringTask) {
      // Count associated tasks
      const tasks = JSON.parse(localStorage.getItem('tasks') || '[]');
      const associatedTasks = tasks.filter(t => t.recurringTaskId === recurringTask.id);
      
      const now = new Date();
      const counts = {
        future: 0,
        completed: 0,
        inProgress: 0
      };
      
      associatedTasks.forEach(task => {
        if (task.status === 'completed') {
          counts.completed++;
        } else if (task.status === 'in-progress') {
          counts.inProgress++;
        } else {
          const dueDate = new Date(task.dueDate);
          if (dueDate >= now) {
            counts.future++;
          }
        }
      });
      
      setTaskCounts(counts);
    }
  }, [isOpen, recurringTask]);

  const handleDelete = () => {
    if (confirmText === 'DELETE') {
      onConfirm();
    }
  };

  if (!isOpen) return null;

  return (
    <div className="modal-overlay">
      <div className="modal delete-modal">
        <div className="modal-header">
          <h2>‚ö†Ô∏è Delete Recurring Task</h2>
          <button onClick={onClose} className="close-btn">√ó</button>
        </div>
        
        <div className="modal-body">
          <div className="warning-box">
            <h3>Are you sure you want to delete "{recurringTask.name}"?</h3>
            
            <div className="impact-summary">
              <p><strong>This action will:</strong></p>
              <ul>
                <li>üóìÔ∏è Delete {taskCounts.future} future scheduled tasks</li>
                <li>üìä Preserve {taskCounts.completed} completed tasks for historical data</li>
                {taskCounts.inProgress > 0 && (
                  <li>‚ö° Keep {taskCounts.inProgress} in-progress tasks active</li>
                )}
              </ul>
              
              <p className="warning-text">
                ‚ö†Ô∏è This action cannot be undone. The recurring task will be permanently deleted, 
                but historical data will be preserved for reporting.
              </p>
            </div>
            
            <div className="confirm-section">
              <p>Type <strong>DELETE</strong> to confirm:</p>
              <input
                type="text"
                value={confirmText}
                onChange={(e) => setConfirmText(e.target.value)}
                placeholder="Type DELETE to confirm"
                className="confirm-input"
              />
            </div>
          </div>
        </div>
        
        <div className="modal-footer">
          <button onClick={onClose} className="btn-secondary">Cancel</button>
          <button 
            onClick={handleDelete} 
            className="btn-danger"
            disabled={confirmText !== 'DELETE'}
          >
            Delete Recurring Task
          </button>
        </div>
      </div>
    </div>
  );
};
```

## Step 2: Implement Delete Logic with Ghost Task Creation

```tsx
const deleteRecurringTask = (recurringTaskId) => {
  console.log('Deleting recurring task:', recurringTaskId);
  
  // Get the recurring task
  const recurringTasks = JSON.parse(localStorage.getItem('recurringTasks') || '[]');
  const recurringTask = recurringTasks.find(rt => rt.id === recurringTaskId);
  
  if (!recurringTask) {
    console.error('Recurring task not found');
    return;
  }
  
  // Create ghost task for historical reference
  const ghostTask = {
    ...recurringTask,
    isGhost: true,
    deletedAt: new Date().toISOString(),
    deletedBy: getCurrentUser().id,
    originalId: recurringTask.id
  };
  
  // Save ghost task to separate storage
  const ghostTasks = JSON.parse(localStorage.getItem('ghostRecurringTasks') || '[]');
  ghostTasks.push(ghostTask);
  localStorage.setItem('ghostRecurringTasks', JSON.stringify(ghostTasks));
  
  // Delete future pending tasks
  deleteFutureTasks(recurringTaskId);
  
  // Update existing completed/in-progress tasks to reference ghost
  updateHistoricalTasks(recurringTaskId, ghostTask.id);
  
  // Remove from active recurring tasks
  const updatedRecurringTasks = recurringTasks.filter(rt => rt.id !== recurringTaskId);
  localStorage.setItem('recurringTasks', JSON.stringify(updatedRecurringTasks));
  
  // Log the deletion
  logDeletion(recurringTask, ghostTask);
  
  // Trigger UI update
  window.dispatchEvent(new CustomEvent('recurringTaskDeleted', { 
    detail: { recurringTaskId, ghostTaskId: ghostTask.id } 
  }));
};
```

## Step 3: Delete Future Tasks

```tsx
const deleteFutureTasks = (recurringTaskId) => {
  const tasks = JSON.parse(localStorage.getItem('tasks') || '[]');
  const now = new Date();
  now.setHours(0, 0, 0, 0);
  
  const updatedTasks = tasks.filter(task => {
    // Keep task if it's not from this recurring task
    if (task.recurringTaskId !== recurringTaskId) {
      return true;
    }
    
    // Keep completed tasks
    if (task.status === 'completed') {
      return true;
    }
    
    // Keep in-progress tasks
    if (task.status === 'in-progress' || task.startedAt) {
      return true;
    }
    
    // Delete future pending tasks
    const dueDate = new Date(task.dueDate);
    dueDate.setHours(0, 0, 0, 0);
    
    if (dueDate >= now) {
      console.log('Deleting future task:', task.id, 'due on', dueDate.toLocaleDateString());
      return false; // Delete this task
    }
    
    return true; // Keep past pending tasks
  });
  
  console.log(`Deleted ${tasks.length - updatedTasks.length} future tasks`);
  localStorage.setItem('tasks', JSON.stringify(updatedTasks));
};
```

## Step 4: Update Historical Tasks to Reference Ghost

```tsx
const updateHistoricalTasks = (oldRecurringTaskId, ghostTaskId) => {
  const tasks = JSON.parse(localStorage.getItem('tasks') || '[]');
  
  const updatedTasks = tasks.map(task => {
    if (task.recurringTaskId === oldRecurringTaskId) {
      return {
        ...task,
        recurringTaskId: ghostTaskId,
        isFromGhostRecurring: true,
        ghostRecurringTaskName: task.name // Preserve original name
      };
    }
    return task;
  });
  
  localStorage.setItem('tasks', JSON.stringify(updatedTasks));
  
  const updatedCount = updatedTasks.filter(t => t.isFromGhostRecurring).length;
  console.log(`Updated ${updatedCount} historical tasks to reference ghost task`);
};
```

## Step 5: Add Delete Button Handler

Update the recurring task UI to handle delete:

```tsx
const handleDeleteClick = (recurringTask) => {
  setSelectedRecurringTask(recurringTask);
  setShowDeleteModal(true);
};

const handleDeleteConfirm = () => {
  if (selectedRecurringTask) {
    deleteRecurringTask(selectedRecurringTask.id);
    setShowDeleteModal(false);
    setSelectedRecurringTask(null);
    
    // Show success message
    showNotification({
      type: 'success',
      message: `Recurring task "${selectedRecurringTask.name}" has been deleted. Future tasks removed, historical data preserved.`
    });
    
    // Refresh the list
    loadRecurringTasks();
  }
};

// In the recurring task list item
<button 
  onClick={() => handleDeleteClick(recurringTask)} 
  className="btn-icon btn-danger"
  title="Delete recurring task"
>
  <TrashIcon />
  Delete
</button>
```

## Step 6: Create Deletion Log

```tsx
const logDeletion = (recurringTask, ghostTask) => {
  const deletionLogs = JSON.parse(localStorage.getItem('recurringTaskDeletionLogs') || '[]');
  
  const logEntry = {
    id: `deletion_${Date.now()}`,
    timestamp: new Date().toISOString(),
    recurringTaskId: recurringTask.id,
    recurringTaskName: recurringTask.name,
    ghostTaskId: ghostTask.id,
    deletedBy: getCurrentUser().username,
    tasksDeleted: 0, // Will be updated by deleteFutureTasks
    tasksPreserved: 0 // Will be updated by updateHistoricalTasks
  };
  
  deletionLogs.push(logEntry);
  localStorage.setItem('recurringTaskDeletionLogs', JSON.stringify(deletionLogs));
};
```

## Step 7: Add Styles for Delete Modal

```css
.delete-modal {
  max-width: 500px;
}

.warning-box {
  background: #fff3cd;
  border: 1px solid #ffeeba;
  border-radius: 8px;
  padding: 1.5rem;
  margin-bottom: 1rem;
}

.warning-box h3 {
  color: #856404;
  margin-bottom: 1rem;
}

.impact-summary {
  background: white;
  padding: 1rem;
  border-radius: 4px;
  margin: 1rem 0;
}

.impact-summary ul {
  margin: 0.5rem 0;
  padding-left: 1.5rem;
}

.warning-text {
  color: #721c24;
  font-weight: 600;
  margin-top: 1rem;
}

.confirm-section {
  margin-top: 1.5rem;
}

.confirm-input {
  width: 100%;
  padding: 0.5rem;
  margin-top: 0.5rem;
  border: 2px solid #dc3545;
  border-radius: 4px;
  font-size: 1rem;
  text-align: center;
}

.btn-danger:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}
```

## Step 8: Ghost Task Access for Data Page

Create helper functions for the future data page:

```tsx
// For use in the Task Data page only
const getGhostRecurringTasks = () => {
  return JSON.parse(localStorage.getItem('ghostRecurringTasks') || '[]');
};

const getTasksFromGhostRecurring = (ghostTaskId) => {
  const tasks = JSON.parse(localStorage.getItem('tasks') || '[]');
  return tasks.filter(task => 
    task.recurringTaskId === ghostTaskId && 
    task.isFromGhostRecurring === true
  );
};

// Get all historical data for a deleted recurring task
const getGhostRecurringTaskData = (ghostTaskId) => {
  const ghost = getGhostRecurringTasks().find(g => g.id === ghostTaskId);
  const tasks = getTasksFromGhostRecurring(ghostTaskId);
  
  return {
    ghost,
    tasks,
    stats: {
      totalTasks: tasks.length,
      completedTasks: tasks.filter(t => t.status === 'completed').length,
      onTimeCompletion: tasks.filter(t => t.status === 'completed' && !t.completedLate).length
    }
  };
};
```

## Summary

This implementation:
1. **Shows clear warning** with impact summary before deletion
2. **Requires confirmation** by typing "DELETE"
3. **Deletes only future tasks** (today and beyond)
4. **Preserves historical data** (completed and in-progress tasks)
5. **Creates ghost task** for data reference
6. **Updates existing tasks** to reference the ghost
7. **Logs the deletion** for audit purposes
8. **Hides ghost tasks** from recurring tasks page but makes them accessible for data analysis