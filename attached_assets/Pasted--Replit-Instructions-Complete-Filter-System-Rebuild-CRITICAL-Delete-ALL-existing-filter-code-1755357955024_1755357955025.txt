# Replit Instructions: Complete Filter System Rebuild

**CRITICAL: Delete ALL existing filter code and rebuild from scratch. The current system has accumulated too much complexity and conflicting logic.**

## Step 1: DELETE All Existing Filter Code

Find and DELETE:
- All date filtering functions
- All filter state management
- All filter-related utility functions
- Any "ghost task" workarounds
- Any timezone conversion hacks
- Any duplicate-prevention logic in filters

Look for and remove:
```javascript
// DELETE anything like:
filterTasksByDate()
filterTasks()
applyFilters()
// Any complex date comparison logic
// Any filter-related useMemo or useEffect
```

## Step 2: Create Clean Data Structure

Ensure every task has these fields:
```javascript
{
  id: string,
  title: string,
  dueDate: string, // ALWAYS "YYYY-MM-DD" format
  visibleFromDate: string, // "YYYY-MM-DD" - when task becomes visible
  visibleToDate: string, // "YYYY-MM-DD" - last day task is visible
  taskType: 'regular' | 'monthly' | 'bi-weekly-first' | 'bi-weekly-second',
  isOverdue: boolean,
  status: string,
  category: string,
  priority: string,
  // ... other fields
}
```

## Step 3: Build New Filter System

Create a single, clean filter function:

```javascript
// src/utils/taskFiltering.js
export const filterTasks = (tasks, filters) => {
  const {
    selectedDate,
    selectedCategory,
    selectedStatus,
    selectedPriority
  } = filters;

  return tasks.filter(task => {
    // Step 1: Date filtering
    if (selectedDate) {
      const passesDateFilter = checkDateFilter(task, selectedDate);
      if (!passesDateFilter) return false;
    }

    // Step 2: Category filtering
    if (selectedCategory && selectedCategory !== 'all') {
      if (task.category !== selectedCategory) return false;
    }

    // Step 3: Status filtering
    if (selectedStatus && selectedStatus !== 'all') {
      if (task.status !== selectedStatus) return false;
    }

    // Step 4: Priority filtering
    if (selectedPriority && selectedPriority !== 'all') {
      if (task.priority !== selectedPriority) return false;
    }

    // Task passes all filters
    return true;
  });
};

// Date filter logic - CLEAN AND SIMPLE
const checkDateFilter = (task, selectedDate) => {
  // Get today's date for comparison
  const today = new Date().toISOString().split('T')[0];
  const isViewingToday = selectedDate === today;

  // Rule 1: If viewing today, show overdue tasks
  if (isViewingToday && task.isOverdue) {
    return true;
  }

  // Rule 2: Check if selected date is within task's visible range
  if (task.visibleFromDate && task.visibleToDate) {
    return selectedDate >= task.visibleFromDate && 
           selectedDate <= task.visibleToDate;
  }

  // Rule 3: For regular tasks, only show on due date
  return task.dueDate === selectedDate;
};
```

## Step 4: Implement Task Visibility Ranges

When creating/updating tasks, set visibility ranges:

```javascript
const setTaskVisibilityRange = (task) => {
  const taskDate = new Date(task.dueDate);
  const year = taskDate.getFullYear();
  const month = taskDate.getMonth();

  switch (task.taskType) {
    case 'monthly':
      // Visible from 1st to due date (last day of month)
      task.visibleFromDate = `${year}-${String(month + 1).padStart(2, '0')}-01`;
      task.visibleToDate = task.dueDate;
      break;

    case 'bi-weekly-first':
      // Visible from 1st to 14th
      task.visibleFromDate = `${year}-${String(month + 1).padStart(2, '0')}-01`;
      task.visibleToDate = `${year}-${String(month + 1).padStart(2, '0')}-14`;
      break;

    case 'bi-weekly-second':
      // Visible from 15th to last day
      task.visibleFromDate = `${year}-${String(month + 1).padStart(2, '0')}-15`;
      task.visibleToDate = task.dueDate; // Last day of month
      break;

    default:
      // Regular tasks only visible on due date
      task.visibleFromDate = task.dueDate;
      task.visibleToDate = task.dueDate;
  }

  return task;
};
```

## Step 5: Update the UI Component

In your Tasks component, use the new clean filter:

```javascript
import { filterTasks } from '../utils/taskFiltering';

const Tasks = () => {
  const [tasks, setTasks] = useState([]);
  const [filters, setFilters] = useState({
    selectedDate: new Date().toISOString().split('T')[0], // Today
    selectedCategory: 'all',
    selectedStatus: 'all',
    selectedPriority: 'all'
  });

  // Clean filtering - no complex logic here
  const filteredTasks = filterTasks(tasks, filters);

  // Update date filter
  const handleDateChange = (e) => {
    setFilters(prev => ({
      ...prev,
      selectedDate: e.target.value // Simple string, no conversion
    }));
  };

  // Clear date filter
  const clearDateFilter = () => {
    setFilters(prev => ({
      ...prev,
      selectedDate: null
    }));
  };

  return (
    <div>
      {/* Date Filter */}
      <input
        type="date"
        value={filters.selectedDate || ''}
        onChange={handleDateChange}
      />
      <button onClick={clearDateFilter}>Show All Dates</button>

      {/* Task List */}
      {filteredTasks.map(task => (
        <TaskCard key={task.id} task={task} />
      ))}
    </div>
  );
};
```

## Step 6: Test Cases

Add debug logging to verify the new system:

```javascript
// Temporary debug function
const debugFiltering = () => {
  console.log('=== FILTER SYSTEM TEST ===');
  
  const testDate = '2025-08-16';
  const allTasks = getTasks(); // Your task getter
  const filtered = filterTasks(allTasks, { selectedDate: testDate });
  
  console.log(`Total tasks: ${allTasks.length}`);
  console.log(`Filtered tasks for ${testDate}: ${filtered.length}`);
  
  filtered.forEach(task => {
    console.log(`- ${task.title}`);
    console.log(`  Due: ${task.dueDate}`);
    console.log(`  Visible: ${task.visibleFromDate} to ${task.visibleToDate}`);
  });
};
```

## Step 7: Migration for Existing Tasks

Add visibility ranges to existing tasks:

```javascript
const migrateExistingTasks = () => {
  const tasks = getAllTasks();
  
  tasks.forEach(task => {
    // Set task type if not present
    if (!task.taskType) {
      if (task.recurringPattern === 'monthly') {
        task.taskType = 'monthly';
      } else if (task.recurringPattern === 'bi-weekly') {
        // Determine which half based on due date
        const day = parseInt(task.dueDate.split('-')[2]);
        task.taskType = day <= 14 ? 'bi-weekly-first' : 'bi-weekly-second';
      } else {
        task.taskType = 'regular';
      }
    }
    
    // Set visibility range
    setTaskVisibilityRange(task);
    
    // Save updated task
    saveTask(task);
  });
};
```

## Summary

This rebuild:
1. **Removes** all complex, buggy filter logic
2. **Uses** simple string dates throughout (no timezone issues)
3. **Implements** clear visibility ranges for each task type
4. **Handles** the "show overdue when viewing today" rule
5. **Keeps** filtering logic in one place, easy to debug

The new system is:
- **Predictable**: Clear rules for what shows when
- **Debuggable**: Simple logic, easy to trace
- **Maintainable**: No accumulated complexity
- **Reliable**: No ghost tasks or timezone bugs

**IMPORTANT**: After implementing, run the migration to add visibility ranges to all existing tasks, then test with the debug function to ensure everything works as expected.