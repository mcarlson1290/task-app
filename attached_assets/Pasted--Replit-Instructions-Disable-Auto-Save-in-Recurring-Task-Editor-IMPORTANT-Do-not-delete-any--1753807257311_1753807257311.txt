# Replit Instructions: Disable Auto-Save in Recurring Task Editor

**IMPORTANT: Do not delete any existing tasks, recurring tasks, or user data. Only update the code functionality while preserving all existing data.**

## Core Principle: NO AUTO-SAVE
The recurring task editor should NEVER save automatically. Changes are only saved when the user explicitly clicks the "Save" button.

## Step 1: Find and Remove ALL Auto-Save Triggers
Search for and remove/comment out any code that automatically saves on:
- Input change (onChange auto-save)
- Blur events (onBlur auto-save)  
- State updates that trigger saves
- useEffect hooks that save on dependency changes
- Any debounced auto-save functions

```javascript
// REMOVE patterns like these:
const handleInputChange = (e) => {
  setTaskData({...taskData, [e.target.name]: e.target.value});
  // saveTask(); // REMOVE THIS
  // debouncedSave(); // REMOVE THIS
};

// REMOVE auto-save effects:
useEffect(() => {
  // if (taskData) {
  //   saveTask(taskData); // REMOVE THIS
  // }
}, [taskData]);

// REMOVE onBlur saves:
<input
  onBlur={() => {
    // saveTask(); // REMOVE THIS
  }}
/>
```

## Step 2: Implement Proper Save Pattern
Only save when the save button is explicitly clicked:

```javascript
const RecurringTaskEditor = ({ task, onClose }) => {
  // Track both original and current state
  const [originalTask] = useState(task);
  const [editedTask, setEditedTask] = useState({...task});
  const [hasChanges, setHasChanges] = useState(false);
  const [isSaving, setIsSaving] = useState(false);
  
  // Update local state ONLY (no saving)
  const handleFieldChange = (field, value) => {
    setEditedTask(prev => ({
      ...prev,
      [field]: value
    }));
    
    // Track if changes were made
    setHasChanges(true);
    
    // DO NOT SAVE HERE
  };
  
  // Only save when save button is clicked
  const handleSaveClick = async () => {
    setIsSaving(true);
    try {
      // Save the recurring task
      await updateRecurringTask(editedTask.id, editedTask);
      
      // Update task instances if needed
      if (editedTask.updateFutureInstances) {
        await updateFutureInstances(editedTask.id, editedTask);
      }
      
      showNotification('Recurring task saved successfully', 'success');
      onClose(); // Close editor after successful save
    } catch (error) {
      console.error('Failed to save:', error);
      showNotification('Failed to save recurring task', 'error');
    } finally {
      setIsSaving(false);
    }
  };
  
  // Cancel without saving
  const handleCancelClick = () => {
    if (hasChanges) {
      if (confirm('You have unsaved changes. Are you sure you want to cancel?')) {
        onClose();
      }
    } else {
      onClose();
    }
  };
  
  return (
    <div className="recurring-task-editor">
      <h2>Edit Recurring Task</h2>
      
      {/* Form fields */}
      <div className="form-section">
        <label>Task Name</label>
        <input
          type="text"
          value={editedTask.name}
          onChange={(e) => handleFieldChange('name', e.target.value)}
          // NO onBlur save
          // NO auto-save
        />
      </div>
      
      <div className="form-section">
        <label>Frequency</label>
        <select
          value={editedTask.frequency}
          onChange={(e) => handleFieldChange('frequency', e.target.value)}
        >
          <option value="daily">Daily</option>
          <option value="weekly">Weekly</option>
          <option value="monthly">Monthly</option>
        </select>
      </div>
      
      {/* Checklist steps */}
      <div className="checklist-section">
        <h3>Checklist Steps</h3>
        {editedTask.checklist?.map((step, index) => (
          <div key={step.id} className="step-item">
            {/* Step content */}
            {/* Any changes here should also NOT auto-save */}
          </div>
        ))}
      </div>
      
      {/* Save/Cancel buttons */}
      <div className="editor-actions">
        <button 
          onClick={handleSaveClick}
          disabled={isSaving || !hasChanges}
          className="save-btn primary"
        >
          {isSaving ? 'Saving...' : 'Save Changes'}
        </button>
        
        <button 
          onClick={handleCancelClick}
          disabled={isSaving}
          className="cancel-btn"
        >
          Cancel
        </button>
        
        {hasChanges && (
          <span className="unsaved-indicator">
            â€¢ Unsaved changes
          </span>
        )}
      </div>
    </div>
  );
};
```

## Step 3: Remove Settings Auto-Save
For the settings modal specifically:

```javascript
const TaskSettingsModal = ({ task, isOpen, onClose }) => {
  const [settings, setSettings] = useState({
    estimatedTime: task.estimatedTime,
    priority: task.priority,
    notes: task.notes
  });
  
  // Update local state only
  const handleSettingChange = (field, value) => {
    setSettings(prev => ({
      ...prev,
      [field]: value
    }));
    // DO NOT SAVE HERE
  };
  
  // Only save when save button clicked
  const handleSave = async () => {
    try {
      await updateTaskSettings(task.id, settings);
      showNotification('Settings saved', 'success');
      onClose();
    } catch (error) {
      showNotification('Failed to save settings', 'error');
    }
  };
  
  if (!isOpen) return null;
  
  return (
    <div className="modal-overlay">
      <div className="modal-content">
        <h3>Task Settings</h3>
        
        {/* Settings form - no auto-save */}
        
        <div className="modal-actions">
          <button onClick={handleSave}>Save Settings</button>
          <button onClick={onClose}>Cancel</button>
        </div>
      </div>
    </div>
  );
};
```

## Step 4: Add Visual Feedback for Unsaved Changes
Show users when they have unsaved changes:

```css
.unsaved-indicator {
  color: #ff9800;
  font-size: 14px;
  margin-left: 12px;
  font-weight: 500;
}

.editor-actions {
  display: flex;
  align-items: center;
  gap: 12px;
  margin-top: 24px;
  padding-top: 24px;
  border-top: 2px solid #eee;
}

.save-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}
```

## Step 5: Warn Before Losing Changes
Add navigation protection:

```javascript
// Warn if user tries to leave with unsaved changes
useEffect(() => {
  const handleBeforeUnload = (e) => {
    if (hasChanges) {
      e.preventDefault();
      e.returnValue = '';
    }
  };
  
  window.addEventListener('beforeunload', handleBeforeUnload);
  return () => window.removeEventListener('beforeunload', handleBeforeUnload);
}, [hasChanges]);
```

## Key Points:
1. **Never save on input change**
2. **Never save on blur**  
3. **Never save in useEffect**
4. **Only save when "Save" button is clicked**
5. **Always warn before discarding unsaved changes**
6. **Show visual indicator for unsaved changes**

This ensures users have full control over when their changes are saved.