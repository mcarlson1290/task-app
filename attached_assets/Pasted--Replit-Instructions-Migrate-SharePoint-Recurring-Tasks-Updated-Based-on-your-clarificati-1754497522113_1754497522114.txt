// Replit Instructions: Migrate SharePoint Recurring Tasks - Updated

// Based on your clarifications:
// 1. "Week Day" field contains frequency info (daily, weekly, monthly, bi-weekly a/b)
// 2. "Assigned To" maps to ROLES not users
// 3. No location field needed
// 4. Estimated time - leave blank
// 5. Photo proof - leave blank
// 6. Frequency data is in "Week Day" field

// Available Categories from screenshot:
const TASK_CATEGORIES = [
  'Seeding - Microgreens',
  'Seeding - Leafy Greens',
  'Harvest - Microgreens',
  'Harvest - Leafy Greens',
  'Blackout Tasks',
  'Moving',
  'Cleaning',
  'Equipment Maintenance',
  'Inventory',
  'Other'
];

// Step 1: Create the migration script
const migrateRecurringTasks = async () => {
  // Read the CSV file
  const csvData = await window.fs.readFile('Reoccurring Tasks.csv', { encoding: 'utf8' });
  
  // Parse CSV with Papaparse
  const parsed = Papa.parse(csvData, {
    header: true,
    dynamicTyping: true,
    skipEmptyLines: true,
    delimitersToGuess: [',', '\t', '|', ';']
  });
  
  const oldTasks = parsed.data;
  const newTasks = [];
  const migrationReport = {
    successful: 0,
    failed: 0,
    warnings: [],
    errors: [],
    rolesMapped: new Set(),
    categoriesUsed: new Set()
  };
  
  // Step 2: Transform each task
  oldTasks.forEach((oldTask, index) => {
    try {
      // Parse frequency from "Week Day" field
      const frequencyData = parseFrequencyFromWeekDay(oldTask['Week Day']);
      
      const newTask = {
        id: generateId(),
        title: oldTask.Title || 'Untitled Task',
        description: oldTask.Description || oldTask.QuickInfo || '',
        priority: mapPriority(oldTask.Priority),
        
        // Frequency from Week Day field
        frequency: frequencyData.frequency,
        
        // Category - determine from title/description
        category: determineCategory(oldTask.Title, oldTask.Description),
        
        // No location per your instructions
        // location: not used
        
        // Leave blank per instructions
        estimatedTime: null,
        
        // Map to ROLE not user
        assignedRole: mapToRole(oldTask['Assigned To'], oldTask.Title),
        
        // Leave blank per instructions
        requiresPhotoProof: false,
        
        // Process link becomes part of description
        processLink: oldTask.ProcessLink,
        
        // Microgreen specific data
        microgreensData: oldTask['Microgreen Weight'] ? {
          weight: oldTask['Microgreen Weight'],
          // Will need manual variety mapping
        } : null,
        
        // Status
        isActive: true,
        
        // Metadata for tracking
        oldTaskId: oldTask.TaskID,
        oldUniqueId: oldTask.UniqueID,
        migratedFrom: 'SharePoint',
        migrationDate: new Date().toISOString(),
        instances: oldTask.Instances
      };
      
      // Add frequency-specific fields
      if (frequencyData.frequency === 'weekly' && frequencyData.daysOfWeek) {
        newTask.daysOfWeek = frequencyData.daysOfWeek;
      } else if (frequencyData.frequency === 'monthly' && frequencyData.dayOfMonth) {
        newTask.dayOfMonth = frequencyData.dayOfMonth;
      } else if (frequencyData.frequency === 'biweekly' && frequencyData.weekPeriod) {
        newTask.weekPeriod = frequencyData.weekPeriod;
      }
      
      // Track what we're mapping
      if (newTask.assignedRole) {
        migrationReport.rolesMapped.add(newTask.assignedRole);
      }
      migrationReport.categoriesUsed.add(newTask.category);
      
      // Add checklist warning if needed
      if (oldTask['Has A SP Checklist Been Created']) {
        newTask.hasSharePointChecklist = true;
        migrationReport.warnings.push(
          `"${oldTask.Title}" has SharePoint checklist - needs manual checklist creation`
        );
      }
      
      newTasks.push(newTask);
      migrationReport.successful++;
      
    } catch (error) {
      migrationReport.errors.push({
        task: oldTask.Title || `Row ${index + 1}`,
        error: error.message
      });
      migrationReport.failed++;
    }
  });
  
  return { newTasks, migrationReport };
};

// Parse frequency from the Week Day field
const parseFrequencyFromWeekDay = (weekDayField) => {
  if (!weekDayField) return { frequency: 'daily' };
  
  const lower = weekDayField.toLowerCase();
  
  // Check for bi-weekly (combine a and b per your instruction)
  if (lower.includes('bi-weekly') || lower.includes('biweekly') || 
      lower === 'a' || lower === 'b') {
    return { 
      frequency: 'biweekly',
      // Default to first half, will need manual adjustment
      weekPeriod: 'first'
    };
  }
  
  // Check for monthly
  if (lower.includes('month') || /\d+/.test(weekDayField)) {
    const dayMatch = weekDayField.match(/\d+/);
    return {
      frequency: 'monthly',
      dayOfMonth: dayMatch ? parseInt(dayMatch[0]) : 1
    };
  }
  
  // Check for daily
  if (lower.includes('daily') || lower.includes('every day')) {
    return { frequency: 'daily' };
  }
  
  // Parse weekly with specific days
  const days = [];
  const dayMap = {
    'monday': ['mon', 'monday'],
    'tuesday': ['tue', 'tues', 'tuesday'],
    'wednesday': ['wed', 'wednesday'],
    'thursday': ['thu', 'thur', 'thursday'],
    'friday': ['fri', 'friday'],
    'saturday': ['sat', 'saturday'],
    'sunday': ['sun', 'sunday']
  };
  
  Object.entries(dayMap).forEach(([fullDay, patterns]) => {
    patterns.forEach(pattern => {
      if (lower.includes(pattern)) {
        days.push(fullDay);
      }
    });
  });
  
  if (days.length > 0) {
    return {
      frequency: 'weekly',
      daysOfWeek: days
    };
  }
  
  // Default to daily if can't parse
  return { frequency: 'daily' };
};

// Map old priority values
const mapPriority = (oldPriority) => {
  if (!oldPriority) return 'medium';
  
  const priorityMap = {
    'high': 'high',
    'medium': 'medium',
    'low': 'low',
    'normal': 'medium',
    '1': 'high',
    '2': 'medium',
    '3': 'low'
  };
  
  return priorityMap[oldPriority.toLowerCase()] || 'medium';
};

// Determine category based on title/description
const determineCategory = (title, description) => {
  const text = `${title} ${description}`.toLowerCase();
  
  // Check each category in order of specificity
  if (text.includes('seed') && text.includes('microgreen')) {
    return 'Seeding - Microgreens';
  } else if (text.includes('seed') && (text.includes('leafy') || text.includes('lettuce'))) {
    return 'Seeding - Leafy Greens';
  } else if (text.includes('harvest') && text.includes('microgreen')) {
    return 'Harvest - Microgreens';
  } else if (text.includes('harvest') && (text.includes('leafy') || text.includes('lettuce'))) {
    return 'Harvest - Leafy Greens';
  } else if (text.includes('blackout') || text.includes('black out')) {
    return 'Blackout Tasks';
  } else if (text.includes('mov') || text.includes('transfer') || text.includes('rotate')) {
    return 'Moving';
  } else if (text.includes('clean') || text.includes('sanitize') || text.includes('wash')) {
    return 'Cleaning';
  } else if (text.includes('equipment') || text.includes('maintenance') || text.includes('repair')) {
    return 'Equipment Maintenance';
  } else if (text.includes('inventory') || text.includes('count') || text.includes('stock')) {
    return 'Inventory';
  } else {
    return 'Other';
  }
};

// Map to appropriate role based on assigned to and task title
const mapToRole = (assignedTo, taskTitle) => {
  if (!assignedTo) return 'General Staff';
  
  const assigned = assignedTo.toLowerCase();
  const title = taskTitle.toLowerCase();
  
  // Try to infer role from assignment and task
  if (title.includes('seed') || assigned.includes('seed')) {
    return 'Microgreen Seeder';
  } else if (title.includes('harvest') || assigned.includes('harvest')) {
    return 'Harvester';
  } else if (title.includes('deliver') || assigned.includes('deliver')) {
    return 'Delivery Driver';
  } else if (assigned.includes('manager') || assigned.includes('lead')) {
    return 'Manager';
  } else if (assigned.includes('all') || assigned.includes('everyone')) {
    return 'General Staff';
  } else {
    // Default to general staff
    return 'General Staff';
  }
};

// Display migration report
const displayMigrationReport = (report) => {
  console.log('=== MIGRATION REPORT ===');
  console.log(`‚úÖ Successful: ${report.successful} tasks`);
  console.log(`‚ùå Failed: ${report.failed} tasks`);
  
  console.log('\nüìã ROLES MAPPED:');
  Array.from(report.rolesMapped).forEach(role => console.log(`- ${role}`));
  
  console.log('\nüìÅ CATEGORIES USED:');
  Array.from(report.categoriesUsed).forEach(cat => console.log(`- ${cat}`));
  
  if (report.warnings.length > 0) {
    console.log('\n‚ö†Ô∏è WARNINGS:');
    report.warnings.forEach(w => console.log(`- ${w}`));
  }
  
  if (report.errors.length > 0) {
    console.log('\n‚ùå ERRORS:');
    report.errors.forEach(e => console.log(`- Task: ${e.task}, Error: ${e.error}`));
  }
  
  console.log('\n‚úèÔ∏è MANUAL REVIEW NEEDED:');
  console.log('- Bi-weekly tasks: Verify if first or second half of month');
  console.log('- Microgreen varieties: Add specific variety data');
  console.log('- SharePoint checklists: Recreate in new system');
  console.log('- Estimated times: Add for each task');
};

// Import button component
const ImportRecurringTasks = () => {
  const [importing, setImporting] = useState(false);
  const [report, setReport] = useState(null);
  
  const handleImport = async () => {
    setImporting(true);
    try {
      const { newTasks, migrationReport } = await migrateRecurringTasks();
      
      // Save tasks to your system
      newTasks.forEach(task => {
        addRecurringTask(task);
      });
      
      setReport(migrationReport);
      displayMigrationReport(migrationReport);
      
      // Show summary alert
      alert(`Import Complete!\n‚úÖ ${migrationReport.successful} tasks imported\n‚ùå ${migrationReport.failed} failed\n\nCheck console for details.`);
      
    } catch (error) {
      console.error('Import failed:', error);
      alert('Import failed: ' + error.message);
    } finally {
      setImporting(false);
    }
  };
  
  return (
    <div className="import-section" style={{ padding: '20px', border: '1px solid #ddd', borderRadius: '8px', margin: '20px 0' }}>
      <h3>Import SharePoint Tasks</h3>
      <p>Upload your "Reoccurring Tasks.csv" file first, then click import.</p>
      
      <button 
        onClick={handleImport} 
        disabled={importing}
        className="btn btn-primary"
        style={{ 
          backgroundColor: '#28a745',
          color: 'white',
          padding: '10px 20px',
          border: 'none',
          borderRadius: '4px',
          cursor: importing ? 'not-allowed' : 'pointer'
        }}
      >
        {importing ? 'Importing...' : 'Import from CSV'}
      </button>
      
      {report && (
        <div className="import-report" style={{ marginTop: '20px', padding: '15px', backgroundColor: '#f8f9fa', borderRadius: '4px' }}>
          <h4>Import Complete!</h4>
          <p>‚úÖ <strong>{report.successful}</strong> tasks imported successfully</p>
          {report.failed > 0 && <p>‚ùå <strong>{report.failed}</strong> tasks failed</p>}
          {report.warnings.length > 0 && (
            <p>‚ö†Ô∏è <strong>{report.warnings.length}</strong> tasks have SharePoint checklists to recreate</p>
          )}
          <p><em>Check browser console for detailed report</em></p>
        </div>
      )}
    </div>
  );
};