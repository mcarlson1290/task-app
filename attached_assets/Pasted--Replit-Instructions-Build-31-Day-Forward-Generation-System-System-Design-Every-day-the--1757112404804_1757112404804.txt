# Replit Instructions: Build 31-Day Forward Generation System

## System Design

Every day, the system looks at the date 31 days in the future and asks: "What tasks should exist on this future date?" Then it creates them if they don't exist.

## Step 1: Core Generation Function

Build a function that generates tasks for a specific future date:

```javascript
const generateTasksForFutureDate = async (futureDate) => {
  const recurringTemplates = await getRecurringTasks();
  const dayOfMonth = futureDate.getDate();
  const dayOfWeek = futureDate.toLocaleDateString('en-US', { weekday: 'long' });
  const month = futureDate.getMonth();
  const year = futureDate.getFullYear();
  
  for (const template of recurringTemplates) {
    let shouldCreate = false;
    let taskConfig = null;
    
    switch (template.frequency) {
      case 'daily': // Weekly tasks
        if (template.selectedDays?.includes(dayOfWeek)) {
          shouldCreate = true;
          taskConfig = {
            id: `${template.id}-${futureDate.toISOString().split('T')[0]}`,
            visibleFromDate: futureDate.toISOString().split('T')[0],
            dueDate: futureDate.toISOString().split('T')[0]
          };
        }
        break;
        
      case 'biweekly':
        // First half: generate on 1st for days 1-14
        if (dayOfMonth === 1) {
          shouldCreate = true;
          taskConfig = {
            id: `${template.id}-${year}-${String(month + 1).padStart(2, '0')}-01`,
            visibleFromDate: `${year}-${String(month + 1).padStart(2, '0')}-01`,
            dueDate: `${year}-${String(month + 1).padStart(2, '0')}-14`,
            periodLabel: '1st-14th'
          };
        }
        // Second half: generate on 15th for days 15-end
        else if (dayOfMonth === 15) {
          const lastDay = new Date(year, month + 1, 0).getDate();
          shouldCreate = true;
          taskConfig = {
            id: `${template.id}-${year}-${String(month + 1).padStart(2, '0')}-15`,
            visibleFromDate: `${year}-${String(month + 1).padStart(2, '0')}-15`,
            dueDate: `${year}-${String(month + 1).padStart(2, '0')}-${lastDay}`,
            periodLabel: `15th-${lastDay}th`
          };
        }
        break;
        
      case 'monthly':
        if (dayOfMonth === 1) {
          const lastDay = new Date(year, month + 1, 0).getDate();
          shouldCreate = true;
          taskConfig = {
            id: `${template.id}-${year}-${String(month + 1).padStart(2, '0')}`,
            visibleFromDate: `${year}-${String(month + 1).padStart(2, '0')}-01`,
            dueDate: `${year}-${String(month + 1).padStart(2, '0')}-${lastDay}`
          };
        }
        break;
        
      case 'quarterly':
        const quarterStartMonths = [0, 3, 6, 9]; // Jan, Apr, Jul, Oct
        if (quarterStartMonths.includes(month) && dayOfMonth === 1) {
          const quarter = Math.floor(month / 3) + 1;
          const quarterEndDate = new Date(year, month + 3, 0); // Last day of quarter
          shouldCreate = true;
          taskConfig = {
            id: `${template.id}-${year}-Q${quarter}`,
            visibleFromDate: futureDate.toISOString().split('T')[0],
            dueDate: quarterEndDate.toISOString().split('T')[0],
            periodLabel: `Q${quarter}`
          };
        }
        break;
    }
    
    if (shouldCreate && taskConfig) {
      // Check if task already exists
      const exists = await getTaskById(taskConfig.id);
      
      if (!exists) {
        const newTask = {
          ...taskConfig,
          title: template.title,
          type: template.type,
          priority: template.priority,
          status: 'pending',
          assignedTo: template.assignedTo,
          frequency: template.frequency,
          recurringTaskId: template.id,
          checklistTemplate: template.checklistTemplate,
          createdAt: new Date().toISOString()
        };
        
        await saveTask(newTask);
        console.log(`Created task: ${newTask.title} for ${taskConfig.dueDate}`);
      }
    }
  }
};
```

## Step 2: Daily Generation Process

Create a function that runs daily to maintain the 31-day buffer:

```javascript
const runDailyGeneration = async () => {
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  
  // Calculate the date 31 days from now
  const futureDate = new Date(today);
  futureDate.setDate(today.getDate() + 31);
  
  console.log(`Generating tasks for ${futureDate.toDateString()}`);
  await generateTasksForFutureDate(futureDate);
};
```

## Step 3: Initial Population

When starting fresh or after deleting all tasks:

```javascript
const populateNext31Days = async () => {
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  
  console.log('Populating tasks for next 31 days...');
  
  // Generate for each of the next 31 days
  for (let day = 0; day <= 31; day++) {
    const targetDate = new Date(today);
    targetDate.setDate(today.getDate() + day);
    
    await generateTasksForFutureDate(targetDate);
  }
  
  console.log('Population complete');
};
```

## Step 4: Handle Template Updates

When a recurring template is edited, update all uncompleted future tasks:

```javascript
const handleTemplateUpdate = async (templateId, updatedTemplate) => {
  // Get all tasks linked to this template
  const allTasks = await getAllTasks();
  const templateTasks = allTasks.filter(task => 
    task.recurringTaskId === templateId &&
    task.status === 'pending'
  );
  
  // Update each uncompleted task
  for (const task of templateTasks) {
    const updatedTask = {
      ...task,
      title: updatedTemplate.title,
      type: updatedTemplate.type,
      priority: updatedTemplate.priority,
      assignedTo: updatedTemplate.assignedTo,
      checklistTemplate: updatedTemplate.checklistTemplate
    };
    
    await updateTask(updatedTask);
  }
  
  console.log(`Updated ${templateTasks.length} tasks for template ${templateId}`);
};
```

## Step 5: Set Up Automatic Execution

Run generation on app load and daily:

```javascript
// On app initialization
useEffect(() => {
  const initialize = async () => {
    // Check if we need to populate (e.g., after delete)
    const tasks = await getAllTasks();
    if (tasks.length === 0) {
      await populateNext31Days();
    } else {
      // Just generate for today's future date
      await runDailyGeneration();
    }
  };
  
  initialize();
  
  // Schedule daily generation at midnight
  const now = new Date();
  const tomorrow = new Date(now);
  tomorrow.setDate(tomorrow.getDate() + 1);
  tomorrow.setHours(0, 0, 1, 0);
  
  const msUntilMidnight = tomorrow - now;
  
  setTimeout(() => {
    runDailyGeneration();
    // Then run every 24 hours
    setInterval(runDailyGeneration, 24 * 60 * 60 * 1000);
  }, msUntilMidnight);
}, []);
```

## Step 6: Add Manual Controls

Provide buttons for manual generation:

```javascript
<button 
  onClick={populateNext31Days}
  className="px-4 py-2 bg-green-600 text-white rounded"
>
  Generate All (Next 31 Days)
</button>

<button 
  onClick={runDailyGeneration}
  className="px-4 py-2 bg-blue-600 text-white rounded"
>
  Generate Today's Future Tasks
</button>
```

## Key Principles

1. **Tasks are generated for future dates**, not today
2. **31-day buffer** ensures tasks are always ready
3. **Linked to templates** via recurringTaskId
4. **Template changes propagate** to uncompleted tasks
5. **Daily generation** maintains the buffer
6. **Unique IDs** prevent duplicates

## Expected Behavior

- Day 1: Generate tasks for days 1-31
- Day 2: Generate tasks for day 32
- Day 3: Generate tasks for day 33
- And so on...

This maintains a constant 31-day buffer of tasks, all properly linked to their recurring templates.