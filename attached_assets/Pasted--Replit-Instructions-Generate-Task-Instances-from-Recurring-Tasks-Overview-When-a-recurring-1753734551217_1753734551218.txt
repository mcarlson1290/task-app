# Replit Instructions: Generate Task Instances from Recurring Tasks

## Overview
When a recurring task is created, it should immediately generate individual task instances based on the recurrence pattern. Each instance is a regular task that can be completed independently.

## Step 1: Database Schema Update
Ensure tasks table has a link to recurring tasks:

```sql
-- Add to tasks table if not exists
ALTER TABLE tasks ADD COLUMN recurring_task_id INTEGER REFERENCES recurring_tasks(id);
ALTER TABLE tasks ADD COLUMN recurring_instance_date DATE;
```

## Step 2: Task Generation Logic
When creating a recurring task, immediately generate instances:

```javascript
const createRecurringTask = async (recurringTaskData) => {
  try {
    // 1. Create the recurring task parent record
    const recurringTask = await db.query(`
      INSERT INTO recurring_tasks 
      (name, description, frequency, assigned_role, assigned_user_id, 
       days_of_week, day_of_month, start_date, end_date, active, location_id)
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
      RETURNING *
    `, [...values]);
    
    // 2. Generate individual task instances
    await generateTaskInstances(recurringTask.rows[0]);
    
    return recurringTask.rows[0];
  } catch (error) {
    console.error('Error creating recurring task:', error);
    throw error;
  }
};
```

## Step 3: Instance Generation Function
Create the logic to generate instances based on frequency:

```javascript
const generateTaskInstances = async (recurringTask) => {
  const instances = [];
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  
  // Generate instances for next 30 days (adjust as needed)
  const endGeneration = new Date();
  endGeneration.setDate(endGeneration.getDate() + 30);
  
  let currentDate = new Date(recurringTask.start_date || today);
  
  while (currentDate <= endGeneration) {
    let shouldCreate = false;
    
    switch (recurringTask.frequency) {
      case 'daily':
        shouldCreate = true;
        break;
        
      case 'weekly':
        // Check if current day matches selected days
        const dayOfWeek = currentDate.getDay();
        const selectedDays = recurringTask.days_of_week || [];
        shouldCreate = selectedDays.includes(dayOfWeek.toString());
        break;
        
      case 'monthly':
        // Check if current date matches selected day of month
        const dayOfMonth = currentDate.getDate();
        shouldCreate = dayOfMonth === recurringTask.day_of_month;
        break;
    }
    
    if (shouldCreate && currentDate >= today) {
      // Create task instance
      const instance = await createTaskInstance(recurringTask, currentDate);
      instances.push(instance);
    }
    
    // Move to next day
    currentDate.setDate(currentDate.getDate() + 1);
  }
  
  console.log(`Generated ${instances.length} task instances`);
  return instances;
};
```

## Step 4: Create Individual Task Instance
```javascript
const createTaskInstance = async (recurringTask, dueDate) => {
  const task = await db.query(`
    INSERT INTO tasks 
    (name, description, assigned_role, assigned_user_id, due_date, 
     status, priority, location_id, recurring_task_id, recurring_instance_date)
    VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
    RETURNING *
  `, [
    recurringTask.name,
    recurringTask.description,
    recurringTask.assigned_role,
    recurringTask.assigned_user_id,
    dueDate,
    'pending',
    recurringTask.priority || 'normal',
    recurringTask.location_id,
    recurringTask.id,
    dueDate
  ]);
  
  return task.rows[0];
};
```

## Step 5: Update Recurring Task Edit Logic
When editing a recurring task, update all future instances that haven't been started:

```javascript
const updateRecurringTask = async (recurringTaskId, updates) => {
  try {
    // 1. Update the recurring task record
    const updatedTask = await db.query(`
      UPDATE recurring_tasks 
      SET name = $1, description = $2, assigned_role = $3, ...
      WHERE id = $4
      RETURNING *
    `, [...values, recurringTaskId]);
    
    // 2. Update all future instances that haven't been started
    await db.query(`
      UPDATE tasks 
      SET 
        name = $1,
        description = $2,
        assigned_role = $3,
        assigned_user_id = $4
      WHERE 
        recurring_task_id = $5
        AND status = 'pending'
        AND due_date >= CURRENT_DATE
    `, [
      updates.name,
      updates.description,
      updates.assigned_role,
      updates.assigned_user_id,
      recurringTaskId
    ]);
    
    // 3. Regenerate instances if frequency changed
    if (updates.frequency || updates.days_of_week || updates.day_of_month) {
      // Delete future pending instances
      await db.query(`
        DELETE FROM tasks 
        WHERE recurring_task_id = $1 
        AND status = 'pending'
        AND due_date >= CURRENT_DATE
      `, [recurringTaskId]);
      
      // Regenerate with new pattern
      await generateTaskInstances(updatedTask.rows[0]);
    }
    
    return updatedTask.rows[0];
  } catch (error) {
    console.error('Error updating recurring task:', error);
    throw error;
  }
};
```

## Step 6: Display Tasks on Calendar/Task List
Update the tasks query to include generated instances:

```javascript
// When fetching tasks for a specific date
const getTasksForDate = async (date, userId, locationId) => {
  const tasks = await db.query(`
    SELECT 
      t.*,
      rt.frequency as recurrence_frequency,
      rt.id as recurring_task_id
    FROM tasks t
    LEFT JOIN recurring_tasks rt ON t.recurring_task_id = rt.id
    WHERE 
      DATE(t.due_date) = DATE($1)
      AND t.location_id = $2
      AND (
        t.assigned_user_id = $3 
        OR t.assigned_role IN (SELECT role FROM users WHERE id = $3)
      )
    ORDER BY t.priority DESC, t.created_at ASC
  `, [date, locationId, userId]);
  
  return tasks.rows;
};
```

## Step 7: Add Visual Indicator for Recurring Tasks
In the task display component:

```javascript
const TaskCard = ({ task }) => {
  return (
    <div className="task-card">
      <h3>
        {task.name}
        {task.recurring_task_id && (
          <span className="recurring-indicator" title="Recurring Task">ðŸ”„</span>
        )}
      </h3>
      {/* Rest of task display */}
    </div>
  );
};
```

## Step 8: Background Job for Future Generation
Set up a daily job to generate new instances:

```javascript
// Run daily to generate instances for the next 30 days
const generateUpcomingInstances = async () => {
  const activeRecurringTasks = await db.query(`
    SELECT * FROM recurring_tasks WHERE active = true
  `);
  
  for (const recurringTask of activeRecurringTasks.rows) {
    // Check if we need to generate more instances
    const lastInstance = await db.query(`
      SELECT MAX(due_date) as last_due 
      FROM tasks 
      WHERE recurring_task_id = $1
    `, [recurringTask.id]);
    
    const lastDue = lastInstance.rows[0].last_due || new Date();
    const daysAhead = 30;
    
    // Generate more if needed
    if (daysBetween(new Date(), lastDue) < daysAhead) {
      await generateTaskInstances(recurringTask);
    }
  }
};
```

## Testing Steps:
1. Create a daily recurring task
2. Check the tasks table - you should see 30 instances created
3. Go to today's task view - the task should appear
4. Edit the recurring task name
5. Check that all future pending instances update
6. Complete one instance - it should not affect others

## Important Notes:
- Each instance is independent once started
- Only 'pending' status tasks update when recurring task is edited
- Consider performance with many recurring tasks
- May want to limit how far ahead to generate (30 days suggested)