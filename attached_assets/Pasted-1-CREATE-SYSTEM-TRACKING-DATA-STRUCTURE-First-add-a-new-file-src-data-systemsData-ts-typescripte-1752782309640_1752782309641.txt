1. CREATE SYSTEM TRACKING DATA STRUCTURE:
First, add a new file src/data/systemsData.ts:
typescriptexport interface SystemSpot {
  id: string;
  occupied: boolean;
  trayId?: string;
  plantType?: string;
  plantedDate?: Date;
  expectedMove?: Date;
}

export interface GrowingSystem {
  id: string;
  name: string;
  type: 'nursery' | 'blackout' | 'ebbFlow' | 'towers' | 'nft' | 'microgreens';
  category: 'microgreens' | 'leafyGreens';
  location: string;
  configuration: {
    sections?: Array<{
      id: string;
      spots: number;
      spotType?: 'ports' | 'slots' | 'spaces';
    }>;
    totalCapacity: number;
    restrictions?: {
      samePerChannel?: boolean; // For NFT
      maxPerTray?: number;
    };
  };
  currentOccupancy: number;
  spots: SystemSpot[];
}

// Initial systems data
export const defaultSystems: { [location: string]: GrowingSystem[] } = {
  'Grow Space': [
    // Microgreen Systems
    {
      id: 'mg-nursery',
      name: 'Microgreen Nursery',
      type: 'nursery',
      category: 'microgreens',
      location: 'Grow Space',
      configuration: {
        totalCapacity: 100
      },
      currentOccupancy: 0,
      spots: Array(100).fill(null).map((_, i) => ({
        id: `nursery-${i + 1}`,
        occupied: false
      }))
    },
    {
      id: 'mg-blackout',
      name: 'Blackout Area',
      type: 'blackout',
      category: 'microgreens',
      location: 'Grow Space',
      configuration: {
        totalCapacity: 200
      },
      currentOccupancy: 0,
      spots: Array(200).fill(null).map((_, i) => ({
        id: `blackout-${i + 1}`,
        occupied: false
      }))
    },
    // Ebb & Flow Systems
    {
      id: 'ebb-flow-a',
      name: 'Ebb & Flow A',
      type: 'ebbFlow',
      category: 'leafyGreens',
      location: 'Grow Space',
      configuration: {
        sections: [{ id: 'A', spots: 16, spotType: 'spaces' }],
        totalCapacity: 16
      },
      currentOccupancy: 0,
      spots: Array(16).fill(null).map((_, i) => ({
        id: `ebb-a-${i + 1}`,
        occupied: false
      }))
    },
    // Tower Systems
    ...Array(7).fill(null).map((_, i) => ({
      id: `tower-a${i + 1}`,
      name: `Tower A${i + 1}`,
      type: 'towers',
      category: 'leafyGreens',
      location: 'Grow Space',
      configuration: {
        totalCapacity: 44,
        sections: [{ id: `A${i + 1}`, spots: 44, spotType: 'ports' }]
      },
      currentOccupancy: 0,
      spots: Array(44).fill(null).map((_, j) => ({
        id: `tower-a${i + 1}-${j + 1}`,
        occupied: false
      }))
    })),
    // NFT Systems
    {
      id: 'nft-1',
      name: 'NFT Shelf 1',
      type: 'nft',
      category: 'leafyGreens',
      location: 'Grow Space',
      configuration: {
        sections: [
          { id: 'CH1', spots: 18, spotType: 'slots' },
          { id: 'CH2', spots: 18, spotType: 'slots' },
          { id: 'CH3', spots: 18, spotType: 'slots' },
          { id: 'CH4', spots: 18, spotType: 'slots' }
        ],
        totalCapacity: 72,
        restrictions: {
          samePerChannel: true
        }
      },
      currentOccupancy: 0,
      spots: Array(72).fill(null).map((_, i) => ({
        id: `nft-1-${Math.floor(i / 18) + 1}-${(i % 18) + 1}`,
        occupied: false
      }))
    }
  ]
};
2. CREATE SYSTEM AVAILABILITY CHECKER:
Add src/utils/systemAvailability.ts:
typescriptimport { GrowingSystem, SystemSpot } from '../data/systemsData';

export interface AvailableSpot {
  systemId: string;
  systemName: string;
  spotIds: string[];
  systemType: string;
  section?: string;
}

export const findAvailableSpots = (
  systems: GrowingSystem[],
  systemType: string,
  spotsNeeded: number,
  plantType?: string
): AvailableSpot[] => {
  const availableSpots: AvailableSpot[] = [];
  
  const matchingSystems = systems.filter(s => s.type === systemType);
  
  for (const system of matchingSystems) {
    if (system.type === 'nft' && system.configuration.restrictions?.samePerChannel) {
      // Special handling for NFT channels
      for (const section of system.configuration.sections || []) {
        const channelSpots = system.spots.filter(spot => 
          spot.id.includes(section.id) && !spot.occupied
        );
        
        // Check if channel is empty or has same plant type
        const occupiedInChannel = system.spots.filter(spot =>
          spot.id.includes(section.id) && spot.occupied
        );
        
        if (channelSpots.length >= spotsNeeded && 
            (occupiedInChannel.length === 0 || 
             occupiedInChannel.every(s => s.plantType === plantType))) {
          availableSpots.push({
            systemId: system.id,
            systemName: system.name,
            spotIds: channelSpots.slice(0, spotsNeeded).map(s => s.id),
            systemType: system.type,
            section: section.id
          });
        }
      }
    } else {
      // Regular system handling
      const freeSpots = system.spots.filter(spot => !spot.occupied);
      
      if (freeSpots.length >= spotsNeeded) {
        availableSpots.push({
          systemId: system.id,
          systemName: system.name,
          spotIds: freeSpots.slice(0, spotsNeeded).map(s => s.id),
          systemType: system.type
        });
      }
    }
  }
  
  // Sort by most available space first
  return availableSpots.sort((a, b) => b.spotIds.length - a.spotIds.length);
};

export const assignToSystem = (
  system: GrowingSystem,
  spotIds: string[],
  trayId: string,
  plantType: string
): GrowingSystem => {
  const updatedSpots = system.spots.map(spot => {
    if (spotIds.includes(spot.id)) {
      return {
        ...spot,
        occupied: true,
        trayId,
        plantType,
        plantedDate: new Date()
      };
    }
    return spot;
  });
  
  return {
    ...system,
    spots: updatedSpots,
    currentOccupancy: updatedSpots.filter(s => s.occupied).length
  };
};
3. CREATE SYSTEM ASSIGNMENT UI COMPONENT:
Add src/components/SystemAssignment.tsx:
typescriptimport React, { useState, useEffect } from 'react';
import { GrowingSystem, AvailableSpot } from '../types/systems';
import { findAvailableSpots } from '../utils/systemAvailability';

interface SystemAssignmentProps {
  systems: GrowingSystem[];
  systemType: string;
  spotsNeeded: number;
  plantType?: string;
  onAssign: (systemId: string, spotIds: string[]) => void;
  autoSuggest?: boolean;
}

export const SystemAssignment: React.FC<SystemAssignmentProps> = ({
  systems,
  systemType,
  spotsNeeded,
  plantType,
  onAssign,
  autoSuggest = true
}) => {
  const [availableSpots, setAvailableSpots] = useState<AvailableSpot[]>([]);
  const [selectedOption, setSelectedOption] = useState<number>(0);
  
  useEffect(() => {
    const spots = findAvailableSpots(systems, systemType, spotsNeeded, plantType);
    setAvailableSpots(spots);
    
    if (autoSuggest && spots.length > 0) {
      setSelectedOption(0);
    }
  }, [systems, systemType, spotsNeeded, plantType, autoSuggest]);
  
  const handleAssign = () => {
    if (availableSpots[selectedOption]) {
      const selected = availableSpots[selectedOption];
      onAssign(selected.systemId, selected.spotIds);
    }
  };
  
  if (availableSpots.length === 0) {
    return (
      <div className="system-assignment-empty">
        <p>⚠️ No available {systemType} spots for {spotsNeeded} plants</p>
      </div>
    );
  }
  
  return (
    <div className="system-assignment">
      <h4>Select System Assignment:</h4>
      
      {autoSuggest && (
        <div className="auto-suggest-badge">
          ✨ Recommended based on availability
        </div>
      )}
      
      <div className="available-options">
        {availableSpots.map((spot, index) => (
          <div
            key={index}
            className={`system-option ${selectedOption === index ? 'selected' : ''}`}
            onClick={() => setSelectedOption(index)}
          >
            <div className="option-header">
              <input
                type="radio"
                checked={selectedOption === index}
                onChange={() => setSelectedOption(index)}
              />
              <span className="system-name">{spot.systemName}</span>
              {spot.section && <span className="section-badge">{spot.section}</span>}
            </div>
            <div className="option-details">
              <span className="availability">
                {spot.spotIds.length} spots available
              </span>
              <span className="capacity-bar">
                <span 
                  className="capacity-fill"
                  style={{ 
                    width: `${100 - (spot.spotIds.length / spotsNeeded * 100)}%` 
                  }}
                />
              </span>
            </div>
          </div>
        ))}
      </div>
      
      <button 
        className="btn-assign"
        onClick={handleAssign}
        disabled={selectedOption === null}
      >
        Assign to {availableSpots[selectedOption]?.systemName}
      </button>
    </div>
  );
};
4. CREATE AUTO-ASSIGNMENT LOGIC FOR MICROGREENS:
Add src/utils/microgreenAutomation.ts:
typescriptexport interface MicrogreenFlow {
  trayId: string;
  currentStage: 'nursery' | 'blackout' | 'racks' | 'harvested';
  plantedDate: Date;
  movedToBlackout?: Date;
  movedToRacks?: Date;
  expectedHarvest: Date;
}

export const MICROGREEN_TIMINGS = {
  nurseryDuration: 0, // Same day
  blackoutDuration: 2, // 2 days
  racksDeuration: 5, // 5 days on racks
  totalGrowthTime: 7 // Total days
};

export const checkMicrogreenMovements = (
  flows: MicrogreenFlow[],
  systems: GrowingSystem[]
): Array<{ trayId: string; action: string; fromSystem: string; toSystem: string }> => {
  const movements = [];
  const now = new Date();
  
  for (const flow of flows) {
    const daysSincePlanted = Math.floor(
      (now.getTime() - flow.plantedDate.getTime()) / (1000 * 60 * 60 * 24)
    );
    
    if (flow.currentStage === 'nursery' && daysSincePlanted >= 0) {
      // Move to blackout immediately
      movements.push({
        trayId: flow.trayId,
        action: 'move',
        fromSystem: 'nursery',
        toSystem: 'blackout'
      });
    } else if (flow.currentStage === 'blackout' && daysSincePlanted >= 2) {
      // Move to racks after 2 days
      movements.push({
        trayId: flow.trayId,
        action: 'move',
        fromSystem: 'blackout',
        toSystem: 'racks'
      });
    }
  }
  
  return movements;
};

export const executeMicrogreenMovement = (
  movement: { trayId: string; fromSystem: string; toSystem: string },
  systems: GrowingSystem[]
): { success: boolean; updatedSystems?: GrowingSystem[]; error?: string } => {
  try {
    const fromSystem = systems.find(s => s.type === movement.fromSystem);
    const toSystemType = movement.toSystem;
    
    if (!fromSystem) {
      return { success: false, error: 'Source system not found' };
    }
    
    // Find the tray in source system
    const traySpot = fromSystem.spots.find(s => s.trayId === movement.trayId);
    if (!traySpot) {
      return { success: false, error: 'Tray not found in source system' };
    }
    
    // Find available spot in destination
    const availableSpots = findAvailableSpots(
      systems,
      toSystemType,
      1,
      traySpot.plantType
    );
    
    if (availableSpots.length === 0) {
      return { 
        success: false, 
        error: `No available spots in ${toSystemType}` 
      };
    }
    
    // Execute movement
    const updatedSystems = systems.map(system => {
      if (system.id === fromSystem.id) {
        // Remove from source
        return {
          ...system,
          spots: system.spots.map(spot => 
            spot.id === traySpot.id 
              ? { ...spot, occupied: false, trayId: undefined, plantType: undefined }
              : spot
          ),
          currentOccupancy: system.currentOccupancy - 1
        };
      } else if (system.id === availableSpots[0].systemId) {
        // Add to destination
        return assignToSystem(
          system,
          [availableSpots[0].spotIds[0]],
          movement.trayId,
          traySpot.plantType || ''
        );
      }
      return system;
    });
    
    return { success: true, updatedSystems };
  } catch (error) {
    return { success: false, error: String(error) };
  }
};
5. ADD CSS STYLES:
Add to your CSS file:
css/* System Management Styles */
.system-assignment {
  background: white;
  padding: 20px;
  border-radius: 8px;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

.system-assignment h4 {
  margin: 0 0 16px 0;
  color: #1f2937;
}

.auto-suggest-badge {
  background: #fef3c7;
  color: #92400e;
  padding: 8px 12px;
  border-radius: 4px;
  font-size: 14px;
  margin-bottom: 16px;
}

.available-options {
  display: flex;
  flex-direction: column;
  gap: 12px;
  margin-bottom: 20px;
}

.system-option {
  border: 2px solid #e5e7eb;
  border-radius: 8px;
  padding: 16px;
  cursor: pointer;
  transition: all 0.2s;
}

.system-option:hover {
  border-color: #2D8028;
  background: #f9fafb;
}

.system-option.selected {
  border-color: #2D8028;
  background: #f0fdf4;
}

.option-header {
  display: flex;
  align-items: center;
  gap: 12px;
  margin-bottom: 8px;
}

.system-name {
  font-weight: 600;
  color: #1f2937;
}

.section-badge {
  background: #e5e7eb;
  color: #374151;
  padding: 2px 8px;
  border-radius: 4px;
  font-size: 12px;
}

.option-details {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.availability {
  color: #059669;
  font-size: 14px;
}

.capacity-bar {
  width: 100px;
  height: 8px;
  background: #e5e7eb;
  border-radius: 4px;
  overflow: hidden;
  position: relative;
}

.capacity-fill {
  position: absolute;
  top: 0;
  left: 0;
  height: 100%;
  background: #dc2626;
  transition: width 0.3s;
}

.btn-assign {
  width: 100%;
  padding: 12px;
  background: #2D8028;
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 16px;
  cursor: pointer;
  transition: background 0.2s;
}

.btn-assign:hover {
  background: #236020;
}

.btn-assign:disabled {
  background: #9ca3af;
  cursor: not-allowed;
}

.system-assignment-empty {
  background: #fee2e2;
  color: #dc2626;
  padding: 16px;
  border-radius: 6px;
  text-align: center;
}

/* System Management Dashboard */
.system-overview {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: 20px;
  margin-top: 20px;
}

.system-card {
  background: white;
  padding: 20px;
  border-radius: 8px;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

.system-card h3 {
  margin: 0 0 16px 0;
  display: flex;
  align-items: center;
  gap: 8px;
}

.occupancy-meter {
  margin: 16px 0;
}

.occupancy-bar {
  height: 20px;
  background: #e5e7eb;
  border-radius: 10px;
  overflow: hidden;
  position: relative;
}

.occupancy-fill {
  height: 100%;
  background: linear-gradient(90deg, #059669, #2D8028);
  transition: width 0.5s ease;
}

.occupancy-text {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: white;
  font-weight: 600;
  font-size: 14px;
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
}

.system-sections {
  margin-top: 12px;
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

.section-tag {
  background: #f3f4f6;
  color: #374151;
  padding: 4px 12px;
  border-radius: 4px;
  font-size: 13px;
}

.movement-queue {
  background: #fef3c7;
  border: 1px solid #fbbf24;
  border-radius: 6px;
  padding: 12px;
  margin-top: 16px;
}

.movement-queue h4 {
  margin: 0 0 8px 0;
  color: #92400e;
  font-size: 14px;
}

.pending-movement {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 4px 0;
  font-size: 13px;
}

.movement-arrow {
  color: #f59e0b;
}
6. INTEGRATE WITH RECURRING TASKS:
Update your Recurring Tasks component to use the system management:
typescript// In RecurringTasks component, add system assignment to checklist
const handleSystemAssignment = (taskId: string, systemId: string, spotIds: string[]) => {
  // Update task with system assignment
  setTasks(tasks.map(task => 
    task.id === taskId 
      ? { 
          ...task, 
          systemAssignment: { systemId, spotIds } 
        }
      : task
  ));
  
  // Update system occupancy
  updateSystemOccupancy(systemId, spotIds, task.trayId, task.cropType);
};

// Add auto-movement check on task completion
const handleTaskComplete = (taskId: string, checklistData: any) => {
  const task = tasks.find(t => t.id === taskId);
  
  if (task?.cropCategory === 'microgreens') {
    // Trigger automatic movement check
    const movements = checkMicrogreenMovements(
      [{ 
        trayId: task.trayId, 
        currentStage: 'nursery',
        plantedDate: new Date()
      }],
      systems
    );
    
    // Execute movements
    movements.forEach(movement => {
      const result = executeMicrogreenMovement(movement, systems);
      if (result.success && result.updatedSystems) {
        setSystems(result.updatedSystems);
        
        // Log movement
        console.log(`✅ Moved tray ${movement.trayId} from ${movement.fromSystem} to ${movement.toSystem}`);
      }
    });
  }
  
  // Complete task
  completeTask(taskId, checklistData);
};
SUMMARY:
This phase implements:

✅ Equipment tracking with real-time occupancy
✅ Availability checker for all system types
✅ Auto-assignment UI with smart suggestions
✅ Automatic movement logic for microgreens
✅ NFT channel restrictions (same plant per channel)
✅ Visual system overview dashboard

The system now tracks:

Current occupancy of all growing systems
Available spots by system type
Automatic suggestions based on availability
Microgreen flow automation (Nursery → Blackout → Racks)
Manual tracking for leafy greens