Phase 1: Implement enhanced recurring task generation with system configuration

1. CREATE SYSTEM CONFIGURATION MANAGEMENT:
   First, create a new component for managing growing systems in Production Data:
   
   ```jsx
   const SystemConfiguration = ({ systems, onUpdate, isCorporateManager }) => {
     const [editingSystem, setEditingSystem] = useState(null);
     const [showAddSystem, setShowAddSystem] = useState(false);
     
     if (!isCorporateManager) {
       return (
         <div className="access-message">
           <p>System configuration is only available to corporate managers.</p>
         </div>
       );
     }
     
     return (
       <div className="system-configuration">
         <div className="config-header">
           <h3>üè≠ Growing System Configuration</h3>
           <button onClick={() => setShowAddSystem(true)} className="btn-add">
             + Add System
           </button>
         </div>
         
         {/* System Categories */}
         <div className="system-categories">
           <div className="category-section">
             <h4>üå± Microgreen Systems</h4>
             <SystemList 
               systems={systems.microgreens}
               onEdit={setEditingSystem}
               category="microgreens"
             />
           </div>
           
           <div className="category-section">
             <h4>ü•¨ Leafy Green Systems</h4>
             <SystemList 
               systems={systems.leafyGreens}
               onEdit={setEditingSystem}
               category="leafyGreens"
             />
           </div>
         </div>
         
         {/* Add/Edit Modal */}
         {(showAddSystem || editingSystem) && (
           <SystemEditModal
             system={editingSystem}
             onSave={(systemData) => {
               onUpdate(systemData);
               setEditingSystem(null);
               setShowAddSystem(false);
             }}
             onClose={() => {
               setEditingSystem(null);
               setShowAddSystem(false);
             }}
           />
         )}
       </div>
     );
   };

CREATE SYSTEM EDIT MODAL:
jsxconst SystemEditModal = ({ system, onSave, onClose }) => {
  const [formData, setFormData] = useState({
    name: system?.name || '',
    category: system?.category || 'leafyGreens',
    type: system?.type || 'towers',
    configuration: system?.configuration || {
      sections: [],
      capacity: 0,
      portType: 'standard'
    }
  });
  
  const systemTypes = {
    microgreens: ['nursery', 'blackout', 'racks'],
    leafyGreens: ['ebbFlow', 'towers', 'nft']
  };
  
  const handleAddSection = () => {
    const newSection = formData.type === 'towers' 
      ? { id: '', type: 'regular', totalPorts: 44, occupiedPorts: [] }
      : formData.type === 'ebbFlow'
      ? { id: '', capacity: 20, occupied: [] }
      : { id: '', capacity: 18, crop: null, occupied: [] };
      
    setFormData({
      ...formData,
      configuration: {
        ...formData.configuration,
        sections: [...(formData.configuration.sections || []), newSection]
      }
    });
  };
  
  return (
    <div className="modal-overlay">
      <div className="modal-content">
        <h2>{system ? 'Edit System' : 'Add New System'}</h2>
        
        <form onSubmit={(e) => {
          e.preventDefault();
          onSave(formData);
        }}>
          <label>
            System Name
            <input
              type="text"
              value={formData.name}
              onChange={(e) => setFormData({...formData, name: e.target.value})}
              required
            />
          </label>
          
          <label>
            Category
            <select
              value={formData.category}
              onChange={(e) => {
                const category = e.target.value;
                setFormData({
                  ...formData,
                  category,
                  type: systemTypes[category][0]
                });
              }}
            >
              <option value="microgreens">Microgreens</option>
              <option value="leafyGreens">Leafy Greens</option>
            </select>
          </label>
          
          <label>
            System Type
            <select
              value={formData.type}
              onChange={(e) => setFormData({...formData, type: e.target.value})}
            >
              {systemTypes[formData.category].map(type => (
                <option key={type} value={type}>
                  {type.charAt(0).toUpperCase() + type.slice(1)}
                </option>
              ))}
            </select>
          </label>
          
          {/* Dynamic configuration based on type */}
          {formData.type === 'towers' && (
            <div className="tower-config">
              <h4>Tower Configuration</h4>
              <button type="button" onClick={handleAddSection}>
                + Add Tower
              </button>
              {formData.configuration.sections?.map((tower, idx) => (
                <div key={idx} className="tower-row">
                  <input
                    type="text"
                    placeholder="Tower ID (e.g., A1)"
                    value={tower.id}
                    onChange={(e) => {
                      const sections = [...formData.configuration.sections];
                      sections[idx].id = e.target.value;
                      setFormData({
                        ...formData,
                        configuration: { ...formData.configuration, sections }
                      });
                    }}
                  />
                  <select
                    value={tower.type}
                    onChange={(e) => {
                      const sections = [...formData.configuration.sections];
                      sections[idx].type = e.target.value;
                      sections[idx].totalPorts = e.target.value === 'HD' ? 176 : 44;
                      setFormData({
                        ...formData,
                        configuration: { ...formData.configuration, sections }
                      });
                    }}
                  >
                    <option value="regular">Regular (44 ports)</option>
                    <option value="HD">HD (176 ports)</option>
                  </select>
                </div>
              ))}
            </div>
          )}
          
          {formData.type === 'ebbFlow' && (
            <div className="ebb-flow-config">
              <h4>Ebb & Flow Sections</h4>
              <button type="button" onClick={handleAddSection}>
                + Add Section
              </button>
              {formData.configuration.sections?.map((section, idx) => (
                <div key={idx} className="section-row">
                  <input
                    type="text"
                    placeholder="Section (e.g., A)"
                    value={section.id}
                    onChange={(e) => {
                      const sections = [...formData.configuration.sections];
                      sections[idx].id = e.target.value;
                      setFormData({
                        ...formData,
                        configuration: { ...formData.configuration, sections }
                      });
                    }}
                  />
                  <input
                    type="number"
                    placeholder="Capacity"
                    value={section.capacity}
                    onChange={(e) => {
                      const sections = [...formData.configuration.sections];
                      sections[idx].capacity = parseInt(e.target.value);
                      setFormData({
                        ...formData,
                        configuration: { ...formData.configuration, sections }
                      });
                    }}
                  />
                </div>
              ))}
            </div>
          )}
          
          <div className="modal-actions">
            <button type="submit" className="btn-save">Save System</button>
            <button type="button" onClick={onClose} className="btn-cancel">Cancel</button>
          </div>
        </form>
      </div>
    </div>
  );
};

UPDATE RECURRING TASKS TO GENERATE ADVANCE TASKS:
jsx// In the main app or task service
const generateTasksFromRecurring = (recurringTasks, daysAhead = 3) => {
  const generatedTasks = [];
  const today = new Date();
  
  recurringTasks.forEach(recurring => {
    // Generate tasks for the next X days
    for (let i = 0; i <= daysAhead; i++) {
      const taskDate = new Date(today);
      taskDate.setDate(today.getDate() + i);
      
      // Check if this day matches the recurring pattern
      if (shouldGenerateTask(recurring, taskDate)) {
        const task = {
          id: `${recurring.id}-${taskDate.toISOString().split('T')[0]}`,
          title: recurring.title,
          type: recurring.type,
          priority: recurring.priority,
          status: 'pending',
          completionDate: taskDate.toISOString().split('T')[0],
          recurringTaskId: recurring.id,
          isRecurring: true,
          automation: recurring.automation,
          checklistTemplate: recurring.checklistTemplate,
          estimatedTime: recurring.estimatedTime,
          assignedTo: recurring.assignedTo,
          editable: true // Can be edited until started
        };
        
        // Don't regenerate if task already exists
        if (!taskExists(task.id)) {
          generatedTasks.push(task);
        }
      }
    }
  });
  
  return generatedTasks;
};

const shouldGenerateTask = (recurring, date) => {
  const dayOfWeek = date.toLocaleDateString('en-US', { weekday: 'lowercase' });
  
  switch (recurring.frequency) {
    case 'daily':
      return recurring.daysOfWeek?.includes(dayOfWeek) ?? true;
    case 'bi-weekly':
      // 1st and 15th of month
      const dayOfMonth = date.getDate();
      return dayOfMonth === 1 || dayOfMonth === 15;
    case 'monthly':
      // Once per month logic
      return date.getDate() === 1;
    default:
      return false;
  }
};

UPDATE TASK CARD TO SHOW RECURRING INDICATOR:
jsx// In TaskCard component
const TaskCard = ({ task, onStart, onEdit }) => {
  const canEdit = task.isRecurring && task.status === 'pending';
  
  return (
    <div className="task-card">
      <div className="task-header">
        <h4>
          {task.isRecurring && <span className="recurring-icon" title="Recurring Task">üîÑ</span>}
          {task.title}
        </h4>
        {/* ... status badges ... */}
      </div>
      
      {/* ... task content ... */}
      
      <div className="task-actions">
        {canEdit && (
          <button onClick={() => onEdit(task)} className="btn-edit-task">
            ‚úèÔ∏è Edit
          </button>
        )}
        {task.status === 'pending' && (
          <button onClick={() => onStart(task.id)} className="btn-start">
            Start Task
          </button>
        )}
      </div>
    </div>
  );
};

ADD RECURRING TASK EDIT MODAL:
jsxconst RecurringTaskEditModal = ({ task, systems, onSave, onClose }) => {
  const [automation, setAutomation] = useState(task.automation || {
    enabled: false,
    generateTrays: false,
    flow: { type: 'microgreen', stages: [] }
  });
  
  return (
    <div className="modal-overlay">
      <div className="modal-content large-modal">
        <h2>Edit Recurring Task Instance</h2>
        <p className="modal-subtitle">
          Editing task for: {formatDate(task.completionDate)}
        </p>
        
        {/* Basic task fields */}
        <div className="form-section">
          <label>
            Number of Trays
            <input
              type="number"
              value={automation.trayCount}
              onChange={(e) => setAutomation({
                ...automation,
                trayCount: parseInt(e.target.value)
              })}
            />
          </label>
          
          <label>
            Initial System Assignment
            <SystemSelector
              systems={systems}
              cropType={task.type}
              value={automation.initialSystem}
              onChange={(system) => setAutomation({
                ...automation,
                initialSystem: system
              })}
            />
          </label>
        </div>
        
        {/* Flow configuration */}
        <div className="form-section">
          <h3>Movement Flow</h3>
          {automation.flow.type === 'microgreen' ? (
            <div className="flow-display">
              <span>Nursery</span> ‚Üí 
              <span>Blackout (2 days)</span> ‚Üí 
              <span>Microgreen Racks</span>
              <p className="flow-note">‚úÖ Automated movement</p>
            </div>
          ) : (
            <div className="flow-config">
              <p>Ebb & Flow ‚Üí Production Systems</p>
              <label>
                Split to Towers: {automation.flow.splitRatio?.towers * 100}%
                <input
                  type="range"
                  min="0"
                  max="100"
                  value={automation.flow.splitRatio?.towers * 100}
                  onChange={(e) => {
                    const towerRatio = parseInt(e.target.value) / 100;
                    setAutomation({
                      ...automation,
                      flow: {
                        ...automation.flow,
                        splitRatio: {
                          towers: towerRatio,
                          nft: 1 - towerRatio
                        }
                      }
                    });
                  }}
                />
              </label>
              <p className="flow-note">‚ö†Ô∏è Manual movement required</p>
            </div>
          )}
        </div>
        
        <div className="modal-actions">
          <button onClick={() => onSave(automation)} className="btn-save">
            Save Changes
          </button>
          <button onClick={onClose} className="btn-cancel">
            Cancel
          </button>
        </div>
      </div>
    </div>
  );
};


This sets up:

Editable system configuration for corporate managers
Advance task generation from recurring tasks
Recurring task indicators
Edit capability for pending recurring tasks
System assignment during task configuration