# Replit Instructions: Replace with Continuous Verification System

## Remove the Old System Completely

Delete or disable any code that:
- Generates tasks only on specific days (1st, 15th, etc.)
- Waits for trigger dates
- Uses the "generate for day 31" approach

## Build the New Continuous System

### 1. Core Verification Engine

This replaces ALL previous generation logic:

```javascript
const continuousTaskVerification = async () => {
  // Get current state from database
  const templates = await db.collection('recurring_templates').get();
  const existingTasks = await db.collection('tasks').get();
  
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  
  // Check every day in our 31-day window
  for (let offset = 0; offset <= 31; offset++) {
    const checkDate = new Date(today);
    checkDate.setDate(today.getDate() + offset);
    
    await ensureTasksExistForDate(checkDate, templates, existingTasks);
  }
};

const ensureTasksExistForDate = async (date, templates, existingTasks) => {
  const dayOfMonth = date.getDate();
  const month = date.getMonth();
  const year = date.getFullYear();
  
  for (const template of templates) {
    // Determine what tasks should exist on this date
    const requiredTasks = [];
    
    // MONTHLY: Exists throughout entire month
    if (template.frequency === 'monthly') {
      const monthlyTaskId = `${template.id}-${year}-${String(month + 1).padStart(2, '0')}`;
      const shouldExist = !existingTasks.find(t => t.id === monthlyTaskId);
      
      if (shouldExist) {
        requiredTasks.push({
          ...template,
          id: monthlyTaskId,
          visibleFromDate: `${year}-${String(month + 1).padStart(2, '0')}-01`,
          dueDate: `${year}-${String(month + 1).padStart(2, '0')}-${new Date(year, month + 1, 0).getDate()}`,
          recurringTaskId: template.id,
          status: 'pending'
        });
      }
    }
    
    // BI-WEEKLY: First half (1st-14th)
    if (template.frequency === 'biweekly' && dayOfMonth <= 14) {
      const firstHalfId = `${template.id}-${year}-${String(month + 1).padStart(2, '0')}-01`;
      const shouldExist = !existingTasks.find(t => t.id === firstHalfId);
      
      if (shouldExist) {
        requiredTasks.push({
          ...template,
          id: firstHalfId,
          visibleFromDate: `${year}-${String(month + 1).padStart(2, '0')}-01`,
          dueDate: `${year}-${String(month + 1).padStart(2, '0')}-14`,
          recurringTaskId: template.id,
          status: 'pending'
        });
      }
    }
    
    // BI-WEEKLY: Second half (15th-end)
    if (template.frequency === 'biweekly' && dayOfMonth >= 15) {
      const secondHalfId = `${template.id}-${year}-${String(month + 1).padStart(2, '0')}-15`;
      const shouldExist = !existingTasks.find(t => t.id === secondHalfId);
      
      if (shouldExist) {
        const lastDay = new Date(year, month + 1, 0).getDate();
        requiredTasks.push({
          ...template,
          id: secondHalfId,
          visibleFromDate: `${year}-${String(month + 1).padStart(2, '0')}-15`,
          dueDate: `${year}-${String(month + 1).padStart(2, '0')}-${lastDay}`,
          recurringTaskId: template.id,
          status: 'pending'
        });
      }
    }
    
    // WEEKLY: Only on specific days
    if (template.frequency === 'daily') {
      const dayName = date.toLocaleDateString('en-US', { weekday: 'long' });
      if (template.selectedDays?.includes(dayName)) {
        const weeklyTaskId = `${template.id}-${date.toISOString().split('T')[0]}`;
        const shouldExist = !existingTasks.find(t => t.id === weeklyTaskId);
        
        if (shouldExist) {
          requiredTasks.push({
            ...template,
            id: weeklyTaskId,
            visibleFromDate: date.toISOString().split('T')[0],
            dueDate: date.toISOString().split('T')[0],
            recurringTaskId: template.id,
            status: 'pending'
          });
        }
      }
    }
    
    // Save all required tasks
    for (const task of requiredTasks) {
      await db.collection('tasks').doc(task.id).set(task);
    }
  }
};
```

### 2. Automatic Execution System

Run verification automatically without user intervention:

```javascript
// Run on app initialization for EVERY user
const initializeApp = async () => {
  // Check if verification is needed
  const status = await db.collection('system_status').doc('verification').get();
  const lastRun = status?.lastRun ? new Date(status.lastRun) : null;
  const now = new Date();
  
  // Run if never run or more than 30 minutes old
  if (!lastRun || (now - lastRun) > 30 * 60 * 1000) {
    // Acquire lock to prevent concurrent runs
    const lockAcquired = await acquireVerificationLock();
    
    if (lockAcquired) {
      try {
        await continuousTaskVerification();
        
        // Update last run time
        await db.collection('system_status').doc('verification').set({
          lastRun: now.toISOString(),
          ranBy: getCurrentUserId()
        });
      } finally {
        await releaseVerificationLock();
      }
    }
  }
};

// Simple lock mechanism
const acquireVerificationLock = async () => {
  try {
    await db.collection('system_locks').doc('verification').create({
      locked: true,
      lockedAt: new Date().toISOString(),
      expiresAt: new Date(Date.now() + 5 * 60 * 1000).toISOString() // 5 min expiry
    });
    return true;
  } catch (error) {
    // Lock exists - check if expired
    const lock = await db.collection('system_locks').doc('verification').get();
    if (lock && new Date(lock.expiresAt) < new Date()) {
      await db.collection('system_locks').doc('verification').delete();
      return acquireVerificationLock(); // Try again
    }
    return false;
  }
};

const releaseVerificationLock = async () => {
  await db.collection('system_locks').doc('verification').delete();
};
```

### 3. Background Verification

Set up periodic checks:

```javascript
// Run verification periodically
useEffect(() => {
  // Initial check
  initializeApp();
  
  // Check every 30 minutes
  const interval = setInterval(() => {
    initializeApp();
  }, 30 * 60 * 1000);
  
  // Also run when window regains focus
  const handleFocus = () => {
    initializeApp();
  };
  
  window.addEventListener('focus', handleFocus);
  
  return () => {
    clearInterval(interval);
    window.removeEventListener('focus', handleFocus);
  };
}, []);
```

### 4. Template Updates with Verification

When templates change, immediately verify:

```javascript
const updateRecurringTemplate = async (templateId, updates) => {
  // Update template
  await db.collection('recurring_templates').doc(templateId).update(updates);
  
  // Update all pending tasks
  const tasks = await db.collection('tasks')
    .where('recurringTaskId', '==', templateId)
    .where('status', '==', 'pending')
    .get();
    
  for (const task of tasks) {
    await db.collection('tasks').doc(task.id).update({
      ...updates,
      // Preserve task-specific fields
      id: task.id,
      visibleFromDate: task.visibleFromDate,
      dueDate: task.dueDate,
      status: task.status,
      recurringTaskId: task.recurringTaskId
    });
  }
  
  // Run verification to ensure consistency
  await continuousTaskVerification();
};
```

### 5. New Template Handling

When creating a new recurring template:

```javascript
const createRecurringTemplate = async (templateData) => {
  // Save template
  const template = await db.collection('recurring_templates').add(templateData);
  
  // Immediately run verification to create tasks
  await continuousTaskVerification();
  
  return template;
};
```

## Key Benefits of Continuous System

1. **No Trigger Dependencies**: Doesn't matter what day tasks are created
2. **Self-Healing**: Missing tasks are automatically created
3. **Always Current**: Templates changes propagate within 30 minutes
4. **No Manual Intervention**: Completely automatic
5. **Multi-User Safe**: Lock system prevents conflicts

## Expected Behavior

- Tasks exist for all 31 days ahead at all times
- New templates create tasks immediately
- Template changes update within 30 minutes
- No gaps or missing tasks
- Works regardless of when users access the system

This completely replaces the old trigger-based system with continuous verification that ensures tasks always exist and are up-to-date.