# Complete Task Generation System Blueprint

## System Overview

Build a multi-user task management system where:
- Recurring task templates generate time-bound task instances
- All users see the same tasks from a shared database
- Tasks are pre-generated 31 days in advance
- Template changes propagate only to pending tasks

## Database Architecture

### Collections/Tables Required

1. **recurring_templates**
   - Stores the master templates for all recurring tasks
   - Fields: id, title, description, frequency, selectedDays, type, priority, assignedTo, location, checklistTemplate, etc.

2. **tasks**
   - Stores all generated task instances
   - Fields: id, title, all template fields PLUS visibleFromDate, dueDate, status, recurringTaskId, completedAt, completedBy, etc.

3. **system_status**
   - Tracks generation state
   - Single document: { id: 'generation-status', lastRunDate, lastRunTime, generatedThrough }

4. **system_locks**
   - Prevents concurrent generation
   - Temporary documents for locking

## Task Generation Rules

### Monthly Tasks
- **When to Generate**: On the 1st of each month
- **Visibility Period**: 1st through last day of month (28-31 days)
- **Due Date**: Last day of the month
- **Example**: Oct 1 creates task visible Oct 1-31, due Oct 31
- **Task ID Format**: `{templateId}-{YYYY}-{MM}`

### Bi-Weekly Tasks (Two per month)
- **First Half**:
  - Generate on: 1st of month
  - Visible: 1st-14th (14 days)
  - Due: 14th of month
  - Task ID: `{templateId}-{YYYY}-{MM}-01`
- **Second Half**:
  - Generate on: 15th of month
  - Visible: 15th-last day (14-16 days)
  - Due: Last day of month
  - Task ID: `{templateId}-{YYYY}-{MM}-15`

### Weekly Tasks (frequency = 'daily')
- **When to Generate**: Each day that matches selectedDays
- **Visibility Period**: Only that specific day
- **Due Date**: Same day as visibility
- **Task ID Format**: `{templateId}-{YYYY}-{MM}-{DD}`

### Quarterly Tasks
- **When to Generate**: 1st day of quarter (Jan 1, Apr 1, Jul 1, Oct 1)
- **Visibility Period**: Entire quarter (3 months)
- **Due Date**: Last day of quarter
- **Task ID Format**: `{templateId}-{YYYY}-Q{1-4}`

## Core Generation Logic

### 1. Main Generation Function

```javascript
const generateTasksForDateRange = async (startDate, endDate, specificTemplate = null) => {
  // Get templates to process
  const templates = specificTemplate 
    ? [specificTemplate] 
    : await getAllRecurringTemplates();
    
  const tasksCreated = [];
  const currentDate = new Date(startDate);
  
  while (currentDate <= endDate) {
    for (const template of templates) {
      const task = shouldGenerateTask(template, currentDate);
      if (task && !await taskExists(task.id)) {
        await saveTask(task);
        tasksCreated.push(task);
      }
    }
    currentDate.setDate(currentDate.getDate() + 1);
  }
  
  return tasksCreated;
};
```

### 2. Task Creation Logic

```javascript
const shouldGenerateTask = (template, checkDate) => {
  const dayOfMonth = checkDate.getDate();
  const month = checkDate.getMonth();
  const year = checkDate.getFullYear();
  const dayName = checkDate.toLocaleDateString('en-US', { weekday: 'long' });
  
  switch (template.frequency) {
    case 'monthly':
      if (dayOfMonth === 1) {
        const lastDay = new Date(year, month + 1, 0);
        return createTask(template, {
          id: `${template.id}-${year}-${String(month + 1).padStart(2, '0')}`,
          visibleFromDate: formatDate(new Date(year, month, 1)),
          dueDate: formatDate(lastDay)
        });
      }
      break;
      
    case 'biweekly':
      if (dayOfMonth === 1) {
        return createTask(template, {
          id: `${template.id}-${year}-${String(month + 1).padStart(2, '0')}-01`,
          visibleFromDate: formatDate(new Date(year, month, 1)),
          dueDate: formatDate(new Date(year, month, 14))
        });
      }
      if (dayOfMonth === 15) {
        const lastDay = new Date(year, month + 1, 0);
        return createTask(template, {
          id: `${template.id}-${year}-${String(month + 1).padStart(2, '0')}-15`,
          visibleFromDate: formatDate(new Date(year, month, 15)),
          dueDate: formatDate(lastDay)
        });
      }
      break;
      
    case 'daily': // Weekly tasks
      if (template.selectedDays?.includes(dayName)) {
        return createTask(template, {
          id: `${template.id}-${formatDate(checkDate)}`,
          visibleFromDate: formatDate(checkDate),
          dueDate: formatDate(checkDate)
        });
      }
      break;
      
    case 'quarterly':
      const quarterStarts = [0, 3, 6, 9];
      if (quarterStarts.includes(month) && dayOfMonth === 1) {
        const quarterEnd = new Date(year, month + 3, 0);
        return createTask(template, {
          id: `${template.id}-${year}-Q${Math.floor(month / 3) + 1}`,
          visibleFromDate: formatDate(checkDate),
          dueDate: formatDate(quarterEnd)
        });
      }
      break;
  }
  
  return null;
};

const createTask = (template, dateInfo) => {
  return {
    ...template, // Copy ALL fields from template
    ...dateInfo, // Add date-specific fields
    recurringTaskId: template.id,
    status: 'pending',
    createdAt: new Date().toISOString()
  };
};

const formatDate = (date) => {
  return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
};
```

## New Recurring Task Handling

When a user creates a new recurring task, generate tasks immediately including current period:

```javascript
const handleNewRecurringTask = async (template) => {
  // Save template first
  await saveRecurringTemplate(template);
  
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  
  // Check if we need to generate current period task
  const currentPeriodTask = getCurrentPeriodTask(template, today);
  if (currentPeriodTask) {
    await saveTask(currentPeriodTask);
  }
  
  // Generate future tasks
  const tomorrow = new Date(today);
  tomorrow.setDate(today.getDate() + 1);
  const endDate = new Date(today);
  endDate.setDate(today.getDate() + 31);
  
  await generateTasksForDateRange(tomorrow, endDate, template);
};

const getCurrentPeriodTask = (template, today) => {
  const dayOfMonth = today.getDate();
  const month = today.getMonth();
  const year = today.getFullYear();
  
  switch (template.frequency) {
    case 'monthly':
      // If we're past the 1st, still create this month's task
      const lastDay = new Date(year, month + 1, 0);
      return createTask(template, {
        id: `${template.id}-${year}-${String(month + 1).padStart(2, '0')}`,
        visibleFromDate: formatDate(new Date(year, month, 1)),
        dueDate: formatDate(lastDay)
      });
      
    case 'biweekly':
      if (dayOfMonth <= 14) {
        // First period
        return createTask(template, {
          id: `${template.id}-${year}-${String(month + 1).padStart(2, '0')}-01`,
          visibleFromDate: formatDate(new Date(year, month, 1)),
          dueDate: formatDate(new Date(year, month, 14))
        });
      } else {
        // Second period
        const lastDay = new Date(year, month + 1, 0);
        return createTask(template, {
          id: `${template.id}-${year}-${String(month + 1).padStart(2, '0')}-15`,
          visibleFromDate: formatDate(new Date(year, month, 15)),
          dueDate: formatDate(lastDay)
        });
      }
      
    case 'daily':
      const dayName = today.toLocaleDateString('en-US', { weekday: 'long' });
      if (template.selectedDays?.includes(dayName)) {
        return createTask(template, {
          id: `${template.id}-${formatDate(today)}`,
          visibleFromDate: formatDate(today),
          dueDate: formatDate(today)
        });
      }
      break;
  }
  
  return null;
};
```

## Daily Maintenance System

### App Initialization

```javascript
const initializeGeneration = async () => {
  const lock = await acquireLock('generation-lock');
  if (!lock) return; // Another user is handling it
  
  try {
    const status = await getGenerationStatus();
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    if (!status || new Date(status.lastRunDate) < today) {
      // First, ensure we have 31 days ahead
      const endDate = new Date(today);
      endDate.setDate(today.getDate() + 31);
      
      await generateTasksForDateRange(today, endDate);
      
      await updateGenerationStatus({
        lastRunDate: formatDate(today),
        lastRunTime: new Date().toISOString(),
        generatedThrough: formatDate(endDate)
      });
    }
  } finally {
    await releaseLock('generation-lock');
  }
};
```

## Template Update Propagation

When a recurring template is edited:

```javascript
const handleTemplateUpdate = async (templateId, updatedData) => {
  // Update the template
  await updateRecurringTemplate(templateId, updatedData);
  
  // Get all tasks for this template
  const tasks = await getTasksByRecurringId(templateId);
  
  // Update only pending tasks
  for (const task of tasks) {
    if (task.status === 'pending') {
      const updatedTask = {
        ...task,
        ...updatedData, // Copy all updated fields
        // Preserve task-specific fields
        id: task.id,
        visibleFromDate: task.visibleFromDate,
        dueDate: task.dueDate,
        status: task.status,
        recurringTaskId: task.recurringTaskId
      };
      
      await updateTask(updatedTask);
    }
  }
};
```

## Task Display Logic

Show tasks based on visibility window:

```javascript
const getVisibleTasks = (allTasks, viewDate) => {
  const checkDate = new Date(viewDate);
  checkDate.setHours(0, 0, 0, 0);
  
  return allTasks.filter(task => {
    if (task.visibleFromDate && task.dueDate) {
      const visibleFrom = new Date(task.visibleFromDate);
      const dueDate = new Date(task.dueDate);
      
      visibleFrom.setHours(0, 0, 0, 0);
      dueDate.setHours(0, 0, 0, 0);
      
      return checkDate >= visibleFrom && checkDate <= dueDate;
    }
    
    // Fallback for tasks without visibility range
    const taskDate = new Date(task.dueDate || task.completionDate);
    taskDate.setHours(0, 0, 0, 0);
    
    return checkDate.getTime() === taskDate.getTime();
  });
};
```

## Fix Day Display Issue

```javascript
const getDayAbbreviation = (dateString) => {
  // Parse YYYY-MM-DD format manually to avoid timezone issues
  const [year, month, day] = dateString.split('-').map(Number);
  const date = new Date(year, month - 1, day);
  
  const days = ['SUN', 'MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT'];
  return days[date.getDay()];
};
```

## Complete System Flow

1. **User Creates Recurring Task**:
   - Save to recurring_templates
   - Generate current period task if applicable
   - Generate next 31 days of tasks

2. **Daily Maintenance**:
   - First user of the day triggers check
   - Generate tasks for day 31 if needed
   - Update system status

3. **Template Updates**:
   - Update template in database
   - Find all linked pending tasks
   - Update task fields while preserving dates/status

4. **Task Display**:
   - Filter by visibility window
   - Show correct day abbreviations
   - Group by date for display

## Testing Checklist

1. Create monthly task on 15th → October task should appear immediately
2. Create bi-weekly task on 20th → Second half task should appear
3. Edit template → Only pending tasks update
4. Multiple users → No duplicate generation
5. Day labels → Match actual calendar days
6. Recurring tasks page → Shows all templates