Phase 2: Implement dynamic checklist system with system assignment

1. CREATE DYNAMIC CHECKLIST BUILDER:
   ```jsx
   const ChecklistBuilder = ({ template, systems, onChange }) => {
     const [steps, setSteps] = useState(template?.steps || []);
     const [showAddStep, setShowAddStep] = useState(false);
     
     const stepTypes = [
       { value: 'instruction', label: 'üìù Text Instruction', icon: 'üìù' },
       { value: 'checkbox', label: '‚úÖ Simple Checkbox', icon: '‚úÖ' },
       { value: 'number-input', label: 'üî¢ Number Input', icon: 'üî¢' },
       { value: 'inventory-select', label: 'üì¶ Inventory Selection', icon: 'üì¶' },
       { value: 'system-assignment', label: 'üè≠ System Assignment', icon: 'üè≠' },
       { value: 'data-capture', label: 'üìä Data Collection', icon: 'üìä' },
       { value: 'photo', label: 'üì∏ Photo Upload', icon: 'üì∏' },
       { value: 'tray-split', label: 'üîÄ Tray Split (Leafy Greens)', icon: 'üîÄ' },
       { value: 'movement-trigger', label: '‚û°Ô∏è Movement Trigger', icon: '‚û°Ô∏è' }
     ];
     
     const addStep = (type) => {
       const newStep = {
         id: Date.now(),
         type,
         label: '',
         required: true,
         config: getDefaultConfig(type)
       };
       
       setSteps([...steps, newStep]);
       onChange([...steps, newStep]);
       setShowAddStep(false);
     };
     
     const getDefaultConfig = (type) => {
       switch (type) {
         case 'number-input':
           return { min: 0, max: 100, unit: '' };
         case 'inventory-select':
           return { category: 'Seeds', allowMultiple: false };
         case 'system-assignment':
           return { systemType: '', autoSuggest: true };
         case 'data-capture':
           return { dataType: 'number', calculation: '' };
         case 'tray-split':
           return { allowCustomSplit: true, defaultSplits: 2 };
         case 'movement-trigger':
           return { fromSystem: '', toSystem: '', automatic: false };
         default:
           return {};
       }
     };
     
     return (
       <div className="checklist-builder">
         <h3>Checklist Steps</h3>
         
         <div className="steps-list">
           {steps.map((step, index) => (
             <ChecklistStepEditor
               key={step.id}
               step={step}
               index={index}
               systems={systems}
               onUpdate={(updatedStep) => {
                 const newSteps = [...steps];
                 newSteps[index] = updatedStep;
                 setSteps(newSteps);
                 onChange(newSteps);
               }}
               onDelete={() => {
                 const newSteps = steps.filter((_, i) => i !== index);
                 setSteps(newSteps);
                 onChange(newSteps);
               }}
               onMoveUp={index > 0 ? () => {
                 const newSteps = [...steps];
                 [newSteps[index-1], newSteps[index]] = [newSteps[index], newSteps[index-1]];
                 setSteps(newSteps);
                 onChange(newSteps);
               } : null}
               onMoveDown={index < steps.length - 1 ? () => {
                 const newSteps = [...steps];
                 [newSteps[index], newSteps[index+1]] = [newSteps[index+1], newSteps[index]];
                 setSteps(newSteps);
                 onChange(newSteps);
               } : null}
             />
           ))}
         </div>
         
         {showAddStep ? (
           <div className="step-type-selector">
             <h4>Select Step Type:</h4>
             <div className="step-type-grid">
               {stepTypes.map(type => (
                 <button
                   key={type.value}
                   onClick={() => addStep(type.value)}
                   className="step-type-btn"
                 >
                   <span className="step-icon">{type.icon}</span>
                   <span>{type.label}</span>
                 </button>
               ))}
             </div>
             <button onClick={() => setShowAddStep(false)} className="btn-cancel">
               Cancel
             </button>
           </div>
         ) : (
           <button onClick={() => setShowAddStep(true)} className="btn-add-step">
             + Add Step
           </button>
         )}
       </div>
     );
   };

CREATE CHECKLIST STEP EDITOR:
jsxconst ChecklistStepEditor = ({ step, index, systems, onUpdate, onDelete, onMoveUp, onMoveDown }) => {
  const [expanded, setExpanded] = useState(false);
  
  return (
    <div className="step-editor">
      <div className="step-header">
        <span className="step-number">{index + 1}</span>
        <input
          type="text"
          value={step.label}
          onChange={(e) => onUpdate({ ...step, label: e.target.value })}
          placeholder={`Enter ${step.type.replace('-', ' ')} label...`}
          className="step-label-input"
        />
        <div className="step-actions">
          {onMoveUp && <button onClick={onMoveUp} title="Move Up">‚¨ÜÔ∏è</button>}
          {onMoveDown && <button onClick={onMoveDown} title="Move Down">‚¨áÔ∏è</button>}
          <button onClick={() => setExpanded(!expanded)} title="Configure">
            ‚öôÔ∏è
          </button>
          <button onClick={onDelete} title="Delete" className="btn-delete-step">
            üóëÔ∏è
          </button>
        </div>
      </div>
      
      {expanded && (
        <div className="step-config">
          <label>
            <input
              type="checkbox"
              checked={step.required}
              onChange={(e) => onUpdate({ ...step, required: e.target.checked })}
            />
            Required step
          </label>
          
          {/* Type-specific configuration */}
          {step.type === 'number-input' && (
            <div className="config-group">
              <label>
                Min Value
                <input
                  type="number"
                  value={step.config.min}
                  onChange={(e) => onUpdate({
                    ...step,
                    config: { ...step.config, min: parseInt(e.target.value) }
                  })}
                />
              </label>
              <label>
                Max Value
                <input
                  type="number"
                  value={step.config.max}
                  onChange={(e) => onUpdate({
                    ...step,
                    config: { ...step.config, max: parseInt(e.target.value) }
                  })}
                />
              </label>
              <label>
                Unit
                <input
                  type="text"
                  value={step.config.unit}
                  onChange={(e) => onUpdate({
                    ...step,
                    config: { ...step.config, unit: e.target.value }
                  })}
                  placeholder="e.g., trays, oz, plants"
                />
              </label>
            </div>
          )}
          
          {step.type === 'system-assignment' && (
            <div className="config-group">
              <label>
                System Type
                <select
                  value={step.config.systemType}
                  onChange={(e) => onUpdate({
                    ...step,
                    config: { ...step.config, systemType: e.target.value }
                  })}
                >
                  <option value="">Any System</option>
                  <option value="microgreen-nursery">Microgreen Nursery</option>
                  <option value="blackout">Blackout Area</option>
                  <option value="microgreen-racks">Microgreen Racks</option>
                  <option value="ebb-flow">Ebb & Flow</option>
                  <option value="towers">Towers</option>
                  <option value="nft">NFT</option>
                </select>
              </label>
              <label>
                <input
                  type="checkbox"
                  checked={step.config.autoSuggest}
                  onChange={(e) => onUpdate({
                    ...step,
                    config: { ...step.config, autoSuggest: e.target.checked }
                  })}
                />
                Auto-suggest available spots
              </label>
            </div>
          )}
          
          {step.type === 'data-capture' && (
            <div className="config-group">
              <label>
                Data Type
                <select
                  value={step.config.dataType}
                  onChange={(e) => onUpdate({
                    ...step,
                    config: { ...step.config, dataType: e.target.value }
                  })}
                >
                  <option value="number">Number</option>
                  <option value="text">Text</option>
                  <option value="select">Selection</option>
                </select>
              </label>
              <label>
                Auto-calculation (optional)
                <input
                  type="text"
                  value={step.config.calculation}
                  onChange={(e) => onUpdate({
                    ...step,
                    config: { ...step.config, calculation: e.target.value }
                  })}
                  placeholder="e.g., trays * 0.75"
                />
              </label>
            </div>
          )}
          
          {step.type === 'tray-split' && (
            <div className="config-group">
              <label>
                Default number of splits
                <input
                  type="number"
                  value={step.config.defaultSplits}
                  onChange={(e) => onUpdate({
                    ...step,
                    config: { ...step.config, defaultSplits: parseInt(e.target.value) }
                  })}
                  min="2"
                  max="10"
                />
              </label>
              <label>
                <input
                  type="checkbox"
                  checked={step.config.allowCustomSplit}
                  onChange={(e) => onUpdate({
                    ...step,
                    config: { ...step.config, allowCustomSplit: e.target.checked }
                  })}
                />
                Allow custom split configuration
              </label>
            </div>
          )}
        </div>
      )}
    </div>
  );
};

CREATE CHECKLIST EXECUTION COMPONENT:
jsxconst ChecklistExecution = ({ task, checklist, systems, onComplete, onProgress }) => {
  const [currentStep, setCurrentStep] = useState(0);
  const [stepData, setStepData] = useState({});
  const [errors, setErrors] = useState({});
  
  const steps = checklist.steps;
  const isLastStep = currentStep === steps.length - 1;
  
  const handleStepComplete = () => {
    const step = steps[currentStep];
    
    // Validate required fields
    if (step.required && !stepData[step.id]) {
      setErrors({ [step.id]: 'This field is required' });
      return;
    }
    
    // Process special step types
    if (step.type === 'system-assignment') {
      handleSystemAssignment(step, stepData[step.id]);
    } else if (step.type === 'movement-trigger') {
      handleMovementTrigger(step, stepData[step.id]);
    } else if (step.type === 'tray-split') {
      handleTraySplit(step, stepData[step.id]);
    }
    
    // Save progress
    onProgress({
      stepIndex: currentStep,
      stepData: stepData
    });
    
    if (isLastStep) {
      onComplete(stepData);
    } else {
      setCurrentStep(currentStep + 1);
      setErrors({});
    }
  };
  
  const renderStepInput = (step) => {
    switch (step.type) {
      case 'instruction':
        return (
          <div className="step-instruction">
            <p>{step.label}</p>
            <button onClick={handleStepComplete} className="btn-acknowledge">
              ‚úì Done
            </button>
          </div>
        );
        
      case 'checkbox':
        return (
          <label className="step-checkbox">
            <input
              type="checkbox"
              checked={stepData[step.id] || false}
              onChange={(e) => setStepData({
                ...stepData,
                [step.id]: e.target.checked
              })}
            />
            <span>{step.label}</span>
          </label>
        );
        
      case 'number-input':
        return (
          <div className="step-number">
            <label>{step.label}</label>
            <div className="number-input-group">
              <input
                type="number"
                value={stepData[step.id] || ''}
                onChange={(e) => setStepData({
                  ...stepData,
                  [step.id]: parseInt(e.target.value)
                })}
                min={step.config.min}
                max={step.config.max}
              />
              {step.config.unit && <span className="unit">{step.config.unit}</span>}
            </div>
          </div>
        );
        
      case 'system-assignment':
        return (
          <SystemAssignmentStep
            step={step}
            systems={systems}
            value={stepData[step.id]}
            onChange={(value) => setStepData({
              ...stepData,
              [step.id]: value
            })}
            cropType={task.type}
          />
        );
        
      case 'tray-split':
        return (
          <TraySplitStep
            step={step}
            systems={systems}
            trays={task.automation?.trayCount || 1}
            value={stepData[step.id]}
            onChange={(value) => setStepData({
              ...stepData,
              [step.id]: value
            })}
          />
        );
        
      case 'inventory-select':
        return (
          <InventorySelectStep
            step={step}
            category={step.config.category}
            value={stepData[step.id]}
            onChange={(value) => setStepData({
              ...stepData,
              [step.id]: value
            })}
          />
        );
        
      case 'data-capture':
        return (
          <DataCaptureStep
            step={step}
            previousData={stepData}
            value={stepData[step.id]}
            onChange={(value) => setStepData({
              ...stepData,
              [step.id]: value
            })}
          />
        );
        
      case 'photo':
        return (
          <PhotoUploadStep
            step={step}
            value={stepData[step.id]}
            onChange={(value) => setStepData({
              ...stepData,
              [step.id]: value
            })}
          />
        );
        
      default:
        return <p>Unknown step type: {step.type}</p>;
    }
  };
  
  return (
    <div className="checklist-execution">
      <div className="checklist-header">
        <h3>{task.title} - Checklist</h3>
        <div className="progress-indicator">
          Step {currentStep + 1} of {steps.length}
        </div>
      </div>
      
      <div className="checklist-progress">
        <div 
          className="progress-bar"
          style={{ width: `${((currentStep + 1) / steps.length) * 100}%` }}
        />
      </div>
      
      <div className="current-step">
        {renderStepInput(steps[currentStep])}
        {errors[steps[currentStep].id] && (
          <p className="error-message">{errors[steps[currentStep].id]}</p>
        )}
      </div>
      
      <div className="checklist-navigation">
        {currentStep > 0 && (
          <button onClick={() => setCurrentStep(currentStep - 1)} className="btn-back">
            ‚Üê Back
          </button>
        )}
        <button onClick={handleStepComplete} className="btn-next">
          {isLastStep ? 'Complete Task' : 'Next ‚Üí'}
        </button>
      </div>
    </div>
  );
};

CREATE SYSTEM ASSIGNMENT COMPONENT:
jsxconst SystemAssignmentStep = ({ step, systems, cropType, value, onChange }) => {
  const [availableSpots, setAvailableSpots] = useState([]);
  const [selectedSpots, setSelectedSpots] = useState(value || []);
  
  useEffect(() => {
    // Find available spots based on system type and crop
    const spots = findAvailableSpots(systems, step.config.systemType, cropType);
    setAvailableSpots(spots);
  }, [systems, step.config.systemType, cropType]);
  
  const findAvailableSpots = (systems, systemType, cropType) => {
    const spots = [];
    
    if (systemType === 'towers') {
      systems.leafyGreens.towers.units.forEach(tower => {
        const available = tower.totalPorts - tower.occupiedPorts.length;
        if (available > 0) {
          spots.push({
            id: tower.id,
            type: 'tower',
            available,
            total: tower.totalPorts,
            display: `Tower ${tower.id} (${available}/${tower.totalPorts} ports)`
          });
        }
      });
    } else if (systemType === 'nft') {
      systems.leafyGreens.nft.channels.forEach(channel => {
        if (!channel.crop || channel.crop === cropType) {
          const available = channel.capacity - channel.occupied.length;
          if (available > 0) {
            spots.push({
              id: `nft-channel-${channel.id}`,
              type: 'nft',
              channelId: channel.id,
              available,
              total: channel.capacity,
              display: `NFT Channel ${channel.id} (${available}/${channel.capacity} spots)`
            });
          }
        }
      });
    } else if (systemType === 'ebb-flow') {
      Object.entries(systems.leafyGreens.ebbFlow.sections).forEach(([section, data]) => {
        const available = data.capacity - data.occupied.length;
        if (available > 0) {
          spots.push({
            id: `ebb-flow-${section}`,
            type: 'ebb-flow',
            section,
            available,
            total: data.capacity,
            display: `Ebb & Flow Section ${section} (${available}/${data.capacity} spots)`
          });
        }
      });
    }
    
    return spots;
  };
  
  return (
    <div className="system-assignment-step">
      <label>{step.label}</label>
      
      {step.config.autoSuggest && availableSpots.length > 0 && (
        <div className="suggested-spots">
          <h4>Available Spots:</h4>
          {availableSpots.map(spot => (
            <button
              key={spot.id}
              onClick={() => {
                setSelectedSpots([spot]);
                onChange([spot]);
              }}
              className={`spot-btn ${selectedSpots.some(s => s.id === spot.id) ? 'selected' : ''}`}
            >
              {spot.display}
            </button>
          ))}
        </div>
      )}
      
      {selectedSpots.length > 0 && (
        <div className="selected-spots">
          <h4>Selected:</h4>
          {selectedSpots.map(spot => (
            <div key={spot.id} className="selected-spot">
              {spot.display}
            </div>
          ))}
        </div>
      )}
      
      {!step.config.autoSuggest && (
        <input
          type="text"
          value={value || ''}
          onChange={(e) => onChange(e.target.value)}
          placeholder="Enter system location manually..."
        />
      )}
    </div>
  );
};

CREATE TRAY SPLIT COMPONENT:
jsxconst TraySplitStep = ({ step, systems, trays, value, onChange }) => {
  const [splits, setSplits] = useState(value || Array(step.config.defaultSplits).fill({
    system: '',
    location: '',
    plants: Math.floor(trays * 50 / step.config.defaultSplits) // Assume 50 plants per tray
  }));
  
  const updateSplit = (index, field, val) => {
    const newSplits = [...splits];
    newSplits[index] = { ...newSplits[index], [field]: val };
    setSplits(newSplits);
    onChange(newSplits);
  };
  
  const addSplit = () => {
    const newSplits = [...splits, { system: '', location: '', plants: 0 }];
    setSplits(newSplits);
    onChange(newSplits);
  };
  
  const removeSplit = (index) => {
    const newSplits = splits.filter((_, i) => i !== index);
    setSplits(newSplits);
    onChange(newSplits);
  };
  
  const totalPlants = trays * 50; // Assume 50 plants per tray
  const allocatedPlants = splits.reduce((sum, split) => sum + (split.plants || 0), 0);
  const remainingPlants = totalPlants - allocatedPlants;
  
  return (
    <div className="tray-split-step">
      <label>{step.label}</label>
      <p className="split-info">
        Splitting {trays} tray(s) ({totalPlants} plants total)
      </p>
      
      <div className="splits-list">
        {splits.map((split, index) => (
          <div key={index} className="split-row">
            <span className="split-number">Split {index + 1}:</span>
            
            <select
              value={split.system}
              onChange={(e) => updateSplit(index, 'system', e.target.value)}
            >
              <option value="">Select System</option>
              <option value="towers">Towers</option>
              <option value="nft">NFT</option>
            </select>
            
            {split.system && (
              <SystemSelector
                systemType={split.system}
                systems={systems}
                value={split.location}
                onChange={(location) => updateSplit(index, 'location', location)}
              />
            )}
            
            <input
              type="number"
              value={split.plants}
              onChange={(e) => updateSplit(index, 'plants', parseInt(e.target.value))}
              min="0"
              max={totalPlants}
              placeholder="# plants"
            />
            
            {splits.length > 2 && (
              <button onClick={() => removeSplit(index)} className="btn-remove">
                ‚úï
              </button>
            )}
          </div>
        ))}
      </div>
      
      {step.config.allowCustomSplit && (
        <button onClick={addSplit} className="btn-add-split">
          + Add Split
        </button>
      )}
      
      <div className={`plants-summary ${remainingPlants !== 0 ? 'error' : 'success'}`}>
        {remainingPlants > 0 && <p>‚ö†Ô∏è {remainingPlants} plants not allocated</p>}
        {remainingPlants < 0 && <p>‚ö†Ô∏è Over-allocated by {Math.abs(remainingPlants)} plants</p>}
        {remainingPlants === 0 && <p>‚úÖ All plants allocated</p>}
      </div>
    </div>
  );
};

ADD CHECKLIST STYLING:
css/* Checklist Builder */
.checklist-builder {
  background: #f9fafb;
  padding: 20px;
  border-radius: 8px;
  margin-top: 20px;
}

.steps-list {
  display: flex;
  flex-direction: column;
  gap: 12px;
  margin-bottom: 20px;
}

.step-editor {
  background: white;
  border: 1px solid #e5e7eb;
  border-radius: 6px;
  padding: 12px;
}

.step-header {
  display: flex;
  align-items: center;
  gap: 12px;
}

.step-number {
  background: #203B17;
  color: white;
  width: 28px;
  height: 28px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: 600;
  font-size: 14px;
}

.step-label-input {
  flex: 1;
  padding: 6px 12px;
  border: 1px solid #d1d5db;
  border-radius: 4px;
}

.step-actions {
  display: flex;
  gap: 4px;
}

.step-actions button {
  background: none;
  border: none;
  cursor: pointer;
  padding: 4px;
  font-size: 16px;
}

.step-actions button:hover {
  background: #f3f4f6;
  border-radius: 4px;
}

.btn-delete-step:hover {
  background: #fee2e2;
}

.step-config {
  margin-top: 12px;
  padding-top: 12px;
  border-top: 1px solid #e5e7eb;
}

.config-group {
  display: flex;
  gap: 12px;
  margin-top: 12px;
}

.config-group label {
  flex: 1;
}

/* Step Type Selector */
.step-type-selector {
  background: white;
  padding: 20px;
  border-radius: 8px;
  border: 2px dashed #d1d5db;
}

.step-type-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
  gap: 12px;
  margin: 16px 0;
}

.step-type-btn {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 12px;
  background: #f9fafb;
  border: 1px solid #e5e7eb;
  border-radius: 6px;
  cursor: pointer;
  text-align: left;
}

.step-type-btn:hover {
  background: #f3f4f6;
  border-color: #203B17;
}

.step-icon {
  font-size: 20px;
}

/* Checklist Execution */
.checklist-execution {
  background: white;
  padding: 24px;
  border-radius: 8px;
  max-width: 600px;
  margin: 0 auto;
}

.checklist-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
}

.progress-indicator {
  color: #6b7280;
  font-size: 14px;
}

.checklist-progress {
  height: 8px;
  background: #e5e7eb;
  border-radius: 4px;
  margin-bottom: 24px;
  overflow: hidden;
}

.progress-bar {
  height: 100%;
  background: #2D8028;
  transition: width 0.3s ease;
}

.current-step {
  min-height: 200px;
  margin-bottom: 24px;
}

.step-instruction {
  text-align: center;
  padding: 40px 20px;
}

.step-instruction p {
  font-size: 18px;
  margin-bottom: 20px;
}

.step-checkbox {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 20px;
  background: #f9fafb;
  border-radius: 6px;
  cursor: pointer;
  font-size: 16px;
}

.step-checkbox input[type="checkbox"] {
  width: 20px;
  height: 20px;
}

.step-number label {
  display: block;
  margin-bottom: 8px;
  font-weight: 500;
}

.number-input-group {
  display: flex;
  align-items: center;
  gap: 8px;
}

.number-input-group input {
  padding: 8px 12px;
  border: 1px solid #d1d5db;
  border-radius: 4px;
  font-size: 16px;
  width: 120px;
}

.unit {
  color: #6b7280;
  font-weight: 500;
}

/* System Assignment */
.system-assignment-step {
  padding: 16px;
  background: #f9fafb;
  border-radius: 6px;
}

.suggested-spots {
  margin-top: 12px;
}

.suggested-spots h4 {
  margin: 0 0 8px 0;
  font-size: 14px;
  color: #6b7280;
}

.spot-btn {
  display: block;
  width: 100%;
  text-align: left;
  padding: 12px;
  margin-bottom: 8px;
  background: white;
  border: 1px solid #e5e7eb;
  border-radius: 6px;
  cursor: pointer;
}

.spot-btn:hover {
  border-color: #2D8028;
}

.spot-btn.selected {
  background: #f0fdf4;
  border-color: #2D8028;
}

/* Tray Split */
.tray-split-step {
  padding: 16px;
  background: #f9fafb;
  border-radius: 6px;
}

.split-info {
  color: #6b7280;
  margin-bottom: 16px;
}

.splits-list {
  display: flex;
  flex-direction: column;
  gap: 12px;
  margin-bottom: 16px;
}

.split-row {
  display: flex;
  align-items: center;
  gap: 8px;
}

.split-number {
  min-width: 60px;
  font-weight: 500;
}

.plants-summary {
  padding: 12px;
  border-radius: 6px;
  text-align: center;
  font-weight: 500;
}

.plants-summary.error {
  background: #fee2e2;
  color: #dc2626;
}

.plants-summary.success {
  background: #d1fae5;
  color: #065f46;
}

.btn-add-split {
  background: #e5e7eb;
  color: #374151;
  padding: 8px 16px;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  margin-bottom: 16px;
}

/* Navigation */
.checklist-navigation {
  display: flex;
  justify-content: space-between;
  padding-top: 20px;
  border-top: 1px solid #e5e7eb;
}

.btn-back,
.btn-next {
  padding: 10px 24px;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  font-weight: 500;
}

.btn-back {
  background: #e5e7eb;
  color: #374151;
}

.btn-next {
  background: #2D8028;
  color: white;
}

.btn-acknowledge {
  background: #2D8028;
  color: white;
  padding: 12px 32px;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  font-size: 16px;
}

.error-message {
  color: #dc2626;
  font-size: 14px;
  margin-top: 8px;
}


This creates a comprehensive dynamic checklist system with:

Visual checklist builder with drag-and-drop reordering
Multiple step types for different data collection
System assignment with availability checking
Tray splitting for leafy greens
Step-by-step execution interface
Progress tracking and validation