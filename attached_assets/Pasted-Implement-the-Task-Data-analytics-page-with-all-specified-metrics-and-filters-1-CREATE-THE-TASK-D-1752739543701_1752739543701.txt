Implement the Task Data analytics page with all specified metrics and filters:

1. CREATE THE TASK DATA PAGE STRUCTURE:
   ```jsx
   const TaskData = () => {
     const currentUser = getCurrentUser();
     const isManager = currentUser.role === 'Manager' || currentUser.role === 'Corporate';
     
     // Get all tasks from context or state
     const [tasks, setTasks] = useState(getAllTasks()); // Would come from your data source
     const [filters, setFilters] = useState({
       dateRange: 'last7days',
       startDate: null,
       endDate: null,
       location: 'all',
       role: 'all',
       taskType: 'all',
       status: 'all',
       priority: 'all',
       assignedUser: 'all',
       recurringTaskSource: 'all',
       checklistCompletionRate: 'all',
       approvalStatus: 'all',
       hasProcessLink: 'all'
     });
     
     // Calculate date range
     const getDateRange = () => {
       const today = new Date();
       const start = new Date();
       
       switch (filters.dateRange) {
         case 'today':
           return { start: today, end: today };
         case 'last7days':
           start.setDate(today.getDate() - 7);
           return { start, end: today };
         case 'last30days':
           start.setDate(today.getDate() - 30);
           return { start, end: today };
         case 'custom':
           return { start: filters.startDate, end: filters.endDate };
         default:
           return { start: null, end: null };
       }
     };
     
     // Filter tasks based on all criteria
     const filteredTasks = useMemo(() => {
       let filtered = [...tasks];
       const { start, end } = getDateRange();
       
       // Date filter
       if (start && end) {
         filtered = filtered.filter(task => {
           const taskDate = new Date(task.completedAt || task.createdAt);
           return taskDate >= start && taskDate <= end;
         });
       }
       
       // Apply other filters
       if (filters.location !== 'all') {
         filtered = filtered.filter(task => task.location === filters.location);
       }
       
       if (filters.role !== 'all') {
         filtered = filtered.filter(task => task.assignedRole === filters.role);
       }
       
       if (filters.taskType !== 'all') {
         filtered = filtered.filter(task => task.type === filters.taskType);
       }
       
       if (filters.status !== 'all') {
         filtered = filtered.filter(task => task.status === filters.status);
       }
       
       if (filters.priority !== 'all') {
         filtered = filtered.filter(task => task.priority === filters.priority);
       }
       
       if (filters.assignedUser !== 'all') {
         filtered = filtered.filter(task => task.assignedTo === filters.assignedUser);
       }
       
       if (filters.checklistCompletionRate !== 'all') {
         filtered = filtered.filter(task => {
           if (!task.checklistItems) return false;
           const rate = (task.checklistCompleted / task.checklistItems) * 100;
           
           switch (filters.checklistCompletionRate) {
             case 'under80':
               return rate < 80;
             case '80to100':
               return rate >= 80 && rate < 100;
             case '100':
               return rate === 100;
             default:
               return true;
           }
         });
       }
       
       if (filters.hasProcessLink !== 'all') {
         filtered = filtered.filter(task => 
           filters.hasProcessLink === 'yes' ? task.processLink : !task.processLink
         );
       }
       
       return filtered;
     }, [tasks, filters]);
     
     if (!isManager) {
       return (
         <div className="access-denied">
           <h2>Access Denied</h2>
           <p>This page is only available to managers.</p>
         </div>
       );
     }
     
     return (
       <div className="task-data-page">
         <div className="page-header">
           <h1>üìä Task Data Analytics</h1>
           <button className="btn-export" onClick={handleExport}>
             üì• Export Data
           </button>
         </div>
         
         {/* Filters Section */}
         <TaskDataFilters 
           filters={filters} 
           setFilters={setFilters}
           tasks={tasks}
         />
         
         {/* Key Metrics Cards */}
         <MetricsCards tasks={filteredTasks} />
         
         {/* Charts Section */}
         <div className="charts-grid">
           <TaskCompletionChart tasks={filteredTasks} />
           <TaskTypeDistribution tasks={filteredTasks} />
           <UserPerformanceChart tasks={filteredTasks} />
           <TimeAnalysisChart tasks={filteredTasks} />
         </div>
         
         {/* Detailed Table */}
         <TaskDataTable tasks={filteredTasks} />
       </div>
     );
   };

CREATE THE FILTERS COMPONENT:
jsxconst TaskDataFilters = ({ filters, setFilters, tasks }) => {
  // Get unique values for dropdowns
  const uniqueRoles = [...new Set(tasks.map(t => t.assignedRole))].filter(Boolean);
  const uniqueUsers = [...new Set(tasks.map(t => t.assignedTo))].filter(Boolean);
  const uniqueTaskTypes = [...new Set(tasks.map(t => t.type))].filter(Boolean);
  const uniqueTaskIds = [...new Set(tasks.map(t => t.recurringTaskId))].filter(Boolean);
  
  return (
    <div className="filters-section">
      <h3>Filters</h3>
      
      <div className="filters-grid">
        {/* Date Range */}
        <div className="filter-group">
          <label>Date Range</label>
          <select 
            value={filters.dateRange}
            onChange={(e) => setFilters({...filters, dateRange: e.target.value})}
          >
            <option value="today">Today</option>
            <option value="last7days">Last 7 Days</option>
            <option value="last30days">Last 30 Days</option>
            <option value="custom">Custom Range</option>
          </select>
          
          {filters.dateRange === 'custom' && (
            <div className="date-inputs">
              <input
                type="date"
                value={filters.startDate}
                onChange={(e) => setFilters({...filters, startDate: e.target.value})}
              />
              <span>to</span>
              <input
                type="date"
                value={filters.endDate}
                onChange={(e) => setFilters({...filters, endDate: e.target.value})}
              />
            </div>
          )}
        </div>
        
        {/* Location */}
        <div className="filter-group">
          <label>Location</label>
          <select 
            value={filters.location}
            onChange={(e) => setFilters({...filters, location: e.target.value})}
          >
            <option value="all">All Locations</option>
            <option value="Grow Space">Grow Space</option>
            {/* Add more locations as needed */}
          </select>
        </div>
        
        {/* Role */}
        <div className="filter-group">
          <label>Role</label>
          <select 
            value={filters.role}
            onChange={(e) => setFilters({...filters, role: e.target.value})}
          >
            <option value="all">All Roles</option>
            {uniqueRoles.map(role => (
              <option key={role} value={role}>{role}</option>
            ))}
          </select>
        </div>
        
        {/* Task Type */}
        <div className="filter-group">
          <label>Task Type</label>
          <select 
            value={filters.taskType}
            onChange={(e) => setFilters({...filters, taskType: e.target.value})}
          >
            <option value="all">All Types</option>
            <option value="Seeding - Microgreens">Seeding - Microgreens</option>
            <option value="Seeding - Leafy Greens">Seeding - Leafy Greens</option>
            <option value="Harvest - Microgreens">Harvest - Microgreens</option>
            <option value="Harvest - Leafy Greens">Harvest - Leafy Greens</option>
            <option value="Blackout Tasks">Blackout Tasks</option>
            <option value="Moving">Moving</option>
            <option value="Packing">Packing</option>
            <option value="Cleaning">Cleaning</option>
            <option value="Inventory">Inventory</option>
            <option value="Equipment Maintenance">Equipment Maintenance</option>
            <option value="Other">Other</option>
          </select>
        </div>
        
        {/* Status */}
        <div className="filter-group">
          <label>Task Status</label>
          <select 
            value={filters.status}
            onChange={(e) => setFilters({...filters, status: e.target.value})}
          >
            <option value="all">All Statuses</option>
            <option value="completed">Completed</option>
            <option value="in-progress">In Progress</option>
            <option value="skipped">Skipped</option>
            <option value="overdue">Overdue</option>
            <option value="paused">Paused</option>
          </select>
        </div>
        
        {/* Priority */}
        <div className="filter-group">
          <label>Priority</label>
          <select 
            value={filters.priority}
            onChange={(e) => setFilters({...filters, priority: e.target.value})}
          >
            <option value="all">All Priorities</option>
            <option value="high">High</option>
            <option value="medium">Medium</option>
            <option value="low">Low</option>
          </select>
        </div>
        
        {/* Assigned User */}
        <div className="filter-group">
          <label>Assigned User</label>
          <select 
            value={filters.assignedUser}
            onChange={(e) => setFilters({...filters, assignedUser: e.target.value})}
          >
            <option value="all">All Users</option>
            {uniqueUsers.map(user => (
              <option key={user} value={user}>{user}</option>
            ))}
          </select>
        </div>
        
        {/* Recurring Task Source */}
        <div className="filter-group">
          <label>Recurring Task Source</label>
          <select 
            value={filters.recurringTaskSource}
            onChange={(e) => setFilters({...filters, recurringTaskSource: e.target.value})}
          >
            <option value="all">All Sources</option>
            {uniqueTaskIds.map(id => (
              <option key={id} value={id}>Task ID: {id}</option>
            ))}
          </select>
        </div>
        
        {/* Advanced Filters */}
        <div className="filter-group">
          <label>Checklist Completion</label>
          <select 
            value={filters.checklistCompletionRate}
            onChange={(e) => setFilters({...filters, checklistCompletionRate: e.target.value})}
          >
            <option value="all">Any</option>
            <option value="under80">Under 80%</option>
            <option value="80to100">80-99%</option>
            <option value="100">100%</option>
          </select>
        </div>
        
        {/* Process Link */}
        <div className="filter-group">
          <label>Has Process Link?</label>
          <select 
            value={filters.hasProcessLink}
            onChange={(e) => setFilters({...filters, hasProcessLink: e.target.value})}
          >
            <option value="all">All</option>
            <option value="yes">Yes</option>
            <option value="no">No</option>
          </select>
        </div>
      </div>
      
      <button 
        className="btn-clear-filters"
        onClick={() => setFilters({
          dateRange: 'last7days',
          startDate: null,
          endDate: null,
          location: 'all',
          role: 'all',
          taskType: 'all',
          status: 'all',
          priority: 'all',
          assignedUser: 'all',
          recurringTaskSource: 'all',
          checklistCompletionRate: 'all',
          approvalStatus: 'all',
          hasProcessLink: 'all'
        })}
      >
        Clear All Filters
      </button>
    </div>
  );
};

CREATE METRICS CARDS:
jsxconst MetricsCards = ({ tasks }) => {
  // Calculate metrics
  const totalTasks = tasks.length;
  const completedTasks = tasks.filter(t => t.status === 'completed').length;
  const overdueTasks = tasks.filter(t => t.isOverdue).length;
  const skippedTasks = tasks.filter(t => t.status === 'skipped').length;
  
  const completionRate = totalTasks > 0 
    ? Math.round((completedTasks / totalTasks) * 100) 
    : 0;
  
  const avgCompletionTime = tasks
    .filter(t => t.actualDuration)
    .reduce((acc, t) => {
      const duration = parseDuration(t.actualDuration);
      return acc + duration;
    }, 0) / completedTasks || 0;
  
  return (
    <div className="metrics-cards">
      <div className="metric-card">
        <div className="metric-icon">üìã</div>
        <div className="metric-value">{totalTasks}</div>
        <div className="metric-label">Total Tasks</div>
      </div>
      
      <div className="metric-card">
        <div className="metric-icon">‚úÖ</div>
        <div className="metric-value">{completionRate}%</div>
        <div className="metric-label">Completion Rate</div>
      </div>
      
      <div className="metric-card">
        <div className="metric-icon">‚è±Ô∏è</div>
        <div className="metric-value">{formatDuration(avgCompletionTime)}</div>
        <div className="metric-label">Avg Duration</div>
      </div>
      
      <div className="metric-card">
        <div className="metric-icon">‚ö†Ô∏è</div>
        <div className="metric-value">{overdueTasks}</div>
        <div className="metric-label">Overdue Tasks</div>
      </div>
      
      <div className="metric-card">
        <div className="metric-icon">‚è≠Ô∏è</div>
        <div className="metric-value">{skippedTasks}</div>
        <div className="metric-label">Skipped Tasks</div>
      </div>
    </div>
  );
};

CREATE CHARTS COMPONENTS:
jsxconst TaskCompletionChart = ({ tasks }) => {
  // Group tasks by date
  const tasksByDate = tasks.reduce((acc, task) => {
    const date = new Date(task.completedAt || task.createdAt).toLocaleDateString();
    if (!acc[date]) {
      acc[date] = { total: 0, completed: 0 };
    }
    acc[date].total++;
    if (task.status === 'completed') {
      acc[date].completed++;
    }
    return acc;
  }, {});
  
  return (
    <div className="chart-container">
      <h3>Task Completion Trend</h3>
      <div className="chart-placeholder">
        {/* In real implementation, use a charting library like recharts */}
        <div className="simple-bar-chart">
          {Object.entries(tasksByDate).slice(-7).map(([date, data]) => (
            <div key={date} className="bar-group">
              <div 
                className="bar completed"
                style={{ height: `${(data.completed / data.total) * 100}%` }}
              />
              <div className="bar-label">{date.split('/')[0]}</div>
            </div>
          ))}
        </div>
      </div>
    </div>
  );
};

const UserPerformanceChart = ({ tasks }) => {
  // Group by user
  const tasksByUser = tasks.reduce((acc, task) => {
    if (!acc[task.assignedTo]) {
      acc[task.assignedTo] = { total: 0, completed: 0, avgTime: [] };
    }
    acc[task.assignedTo].total++;
    if (task.status === 'completed') {
      acc[task.assignedTo].completed++;
      if (task.actualDuration) {
        acc[task.assignedTo].avgTime.push(parseDuration(task.actualDuration));
      }
    }
    return acc;
  }, {});
  
  // Sort by most tasks
  const topUsers = Object.entries(tasksByUser)
    .sort((a, b) => b[1].total - a[1].total)
    .slice(0, 10);
  
  return (
    <div className="chart-container">
      <h3>Top Performers by Task Count</h3>
      <div className="user-performance-list">
        {topUsers.map(([user, data]) => (
          <div key={user} className="user-row">
            <span className="user-name">{user}</span>
            <div className="user-stats">
              <span className="stat">{data.completed} completed</span>
              <span className="completion-rate">
                {Math.round((data.completed / data.total) * 100)}%
              </span>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
};

CREATE DATA TABLE:
jsxconst TaskDataTable = ({ tasks }) => {
  const [sortBy, setSortBy] = useState('completedAt');
  const [sortOrder, setSortOrder] = useState('desc');
  const [currentPage, setCurrentPage] = useState(1);
  const itemsPerPage = 20;
  
  // Sort tasks
  const sortedTasks = [...tasks].sort((a, b) => {
    let aVal = a[sortBy];
    let bVal = b[sortBy];
    
    if (sortBy === 'completedAt' || sortBy === 'createdAt') {
      aVal = new Date(aVal || 0);
      bVal = new Date(bVal || 0);
    }
    
    if (sortOrder === 'asc') {
      return aVal > bVal ? 1 : -1;
    } else {
      return aVal < bVal ? 1 : -1;
    }
  });
  
  // Paginate
  const totalPages = Math.ceil(sortedTasks.length / itemsPerPage);
  const paginatedTasks = sortedTasks.slice(
    (currentPage - 1) * itemsPerPage,
    currentPage * itemsPerPage
  );
  
  const handleSort = (field) => {
    if (sortBy === field) {
      setSortOrder(sortOrder === 'asc' ? 'desc' : 'asc');
    } else {
      setSortBy(field);
      setSortOrder('desc');
    }
  };
  
  return (
    <div className="task-data-table-container">
      <h3>Detailed Task Data</h3>
      
      <div className="table-wrapper">
        <table className="task-data-table">
          <thead>
            <tr>
              <th onClick={() => handleSort('title')}>
                Task Title {sortBy === 'title' && (sortOrder === 'asc' ? '‚Üë' : '‚Üì')}
              </th>
              <th onClick={() => handleSort('assignedTo')}>
                Assigned To {sortBy === 'assignedTo' && (sortOrder === 'asc' ? '‚Üë' : '‚Üì')}
              </th>
              <th onClick={() => handleSort('status')}>
                Status {sortBy === 'status' && (sortOrder === 'asc' ? '‚Üë' : '‚Üì')}
              </th>
              <th onClick={() => handleSort('actualDuration')}>
                Duration {sortBy === 'actualDuration' && (sortOrder === 'asc' ? '‚Üë' : '‚Üì')}
              </th>
              <th onClick={() => handleSort('completedAt')}>
                Completed {sortBy === 'completedAt' && (sortOrder === 'asc' ? '‚Üë' : '‚Üì')}
              </th>
              <th>Checklist</th>
            </tr>
          </thead>
          <tbody>
            {paginatedTasks.map(task => (
              <tr key={task.id} className={task.isOverdue ? 'overdue-row' : ''}>
                <td>{task.title}</td>
                <td>{task.assignedTo}</td>
                <td>
                  <span className={`status-badge status-${task.status}`}>
                    {task.status}
                  </span>
                </td>
                <td>{task.actualDuration || task.estimatedTime}</td>
                <td>
                  {task.completedAt 
                    ? new Date(task.completedAt).toLocaleString()
                    : '-'
                  }
                </td>
                <td>
                  {task.checklistItems 
                    ? `${task.checklistCompleted || 0}/${task.checklistItems}`
                    : '-'
                  }
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>
      
      <div className="table-pagination">
        <button 
          onClick={() => setCurrentPage(p => Math.max(1, p - 1))}
          disabled={currentPage === 1}
        >
          Previous
        </button>
        <span>Page {currentPage} of {totalPages}</span>
        <button 
          onClick={() => setCurrentPage(p => Math.min(totalPages, p + 1))}
          disabled={currentPage === totalPages}
        >
          Next
        </button>
      </div>
    </div>
  );
};

ADD EXPORT FUNCTIONALITY:
javascriptconst handleExport = () => {
  const exportData = filteredTasks.map(task => ({
    'Task Title': task.title,
    'Type': task.type,
    'Assigned To': task.assignedTo,
    'Status': task.status,
    'Priority': task.priority,
    'Created': new Date(task.createdAt).toLocaleDateString(),
    'Completed': task.completedAt ? new Date(task.completedAt).toLocaleDateString() : '',
    'Duration': task.actualDuration || task.estimatedTime,
    'Overdue': task.isOverdue ? 'Yes' : 'No',
    'Checklist Progress': task.checklistItems 
      ? `${task.checklistCompleted || 0}/${task.checklistItems}`
      : 'N/A'
  }));
  
  // Convert to CSV
  const headers = Object.keys(exportData[0]);
  const csv = [
    headers.join(','),
    ...exportData.map(row => 
      headers.map(header => 
        JSON.stringify(row[header] || '')
      ).join(',')
    )
  ].join('\n');
  
  // Download
  const blob = new Blob([csv], { type: 'text/csv' });
  const url = window.URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `task-data-${new Date().toISOString().split('T')[0]}.csv`;
  a.click();
};

ADD STYLING:
css.task-data-page {
  padding: 20px;
  max-width: 1600px;
  margin: 0 auto;
}

.page-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 24px;
}

.btn-export {
  background: #2D8028;
  color: white;
  padding: 10px 20px;
  border: none;
  border-radius: 6px;
  cursor: pointer;
}

/* Filters */
.filters-section {
  background: white;
  padding: 20px;
  border-radius: 8px;
  margin-bottom: 24px;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

.filters-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 16px;
  margin-bottom: 16px;
}

.filter-group label {
  display: block;
  font-size: 12px;
  color: #6b7280;
  margin-bottom: 4px;
  text-transform: uppercase;
}

.filter-group select,
.filter-group input {
  width: 100%;
  padding: 8px;
  border: 1px solid #d1d5db;
  border-radius: 4px;
}

.date-inputs {
  display: flex;
  gap: 8px;
  align-items: center;
  margin-top: 8px;
}

/* Metrics Cards */
.metrics-cards {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 16px;
  margin-bottom: 24px;
}

.metric-card {
  background: white;
  padding: 20px;
  border-radius: 8px;
  text-align: center;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

.metric-icon {
  font-size: 32px;
  margin-bottom: 8px;
}

.metric-value {
  font-size: 28px;
  font-weight: 700;
  color: #203B17;
}

.metric-label {
  font-size: 14px;
  color: #6b7280;
  margin-top: 4px;
}

/* Charts */
.charts-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
  gap: 20px;
  margin-bottom: 24px;
}

.chart-container {
  background: white;
  padding: 20px;
  border-radius: 8px;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

.chart-container h3 {
  margin-top: 0;
  margin-bottom: 16px;
  color: #1f2937;
}

/* Simple bar chart */
.simple-bar-chart {
  display: flex;
  align-items: flex-end;
  height: 200px;
  gap: 8px;
  padding: 0 16px;
}

.bar-group {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  height: 100%;
  justify-content: flex-end;
}

.bar {
  width: 100%;
  background: #2D8028;
  border-radius: 4px 4px 0 0;
  transition: height 0.3s ease;
}

.bar-label {
  font-size: 12px;
  color: #6b7280;
  margin-top: 4px;
}

/* User performance */
.user-performance-list {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.user-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px;
  background: #f9fafb;
  border-radius: 4px;
}

.user-stats {
  display: flex;
  gap: 16px;
  font-size: 14px;
}

.completion-rate {
  font-weight: 600;
  color: #2D8028;
}

/* Table */
.task-data-table-container {
  background: white;
  padding: 20px;
  border-radius: 8px;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

.table-wrapper {
  overflow-x: auto;
}

.task-data-table {
  width: 100%;
  border-collapse: collapse;
}

.task-data-table th {
  background: #f3f4f6;
  padding: 12px;
  text-align: left;
  font-weight: 600;
  cursor: pointer;
  user-select: none;
}

.task-data-table th:hover {
  background: #e5e7eb;
}

.task-data-table td {
  padding: 12px;
  border-bottom: 1px solid #e5e7eb;
}

.task-data-table tr:hover {
  background: #f9fafb;
}

.overdue-row {
  background: #fee2e2;
}

.table-pagination {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 16px;
  margin-top: 16px;
}

.table-pagination button {
  padding: 8px 16px;
  border: 1px solid #d1d5db;
  background: white;
  border-radius: 4px;
  cursor: pointer;
}

.table-pagination button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

/* Mobile responsive */
@media (max-width: 768px) {
  .filters-grid {
    grid-template-columns: 1fr;
  }
  
  .metrics-cards {
    grid-template-columns: 1fr 1fr;
  }
  
  .charts-grid {
    grid-template-columns: 1fr;
  }
  
  .table-wrapper {
    font-size: 14px;
  }
}


This comprehensive Task Data page includes:

All filters from the blueprint
Key operational, performance, and quality metrics
Interactive charts and visualizations
Sortable, paginated data table
CSV export functionality
Mobile responsive design
Manager-only access control